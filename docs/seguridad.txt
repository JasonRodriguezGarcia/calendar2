***************************************
Limitar Intentos de Inicio de Sesi√≥n Login (login limiting)
***************************************
Una de las formas m√°s eficaces de protegerte contra los ataques de fuerza bruta es limitar la cantidad de intentos de 
inicio de sesi√≥n fallidos que un usuario puede hacer en un corto per√≠odo de tiempo. Esto reduce el riesgo de que un atacante 
pueda probar muchas combinaciones de contrase√±as r√°pidamente.

*****
OJO !!! Por defecto, Express no conf√≠a en proxies, as√≠ que ignora esa cabecera.
Para no hacer muy condensado este tema de seguridad, usar limiters, decidirse por un EJEMPLO1 para el anti CSRF
Luego cuando lo tengas todo claro, revisar proxies.txt.
****

Puedes usar un middleware en Express.js como express-rate-limit para implementar esto.
Instalar express-rate-limit:
    npm install express-rate-limit

Ejemplo de configuraci√≥n para proteger las rutas de login:

import rateLimit from 'express-rate-limit';

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // reseteo del bloque a los 15 minutos
  max: 5, // Limitar a 5 intentos
  message: "Demasiados intentos de inicio de sesi√≥n. Por favor, intente de nuevo en 15 minutos.",
  √≥ tambi√©n message: {message: "Demasiados intentos de inicio de sesi√≥n. Por favor, intente de nuevo en 15 minutos."},
  standardHeaders: true,
  legacyHeaders: false,
});

// Usar el rate limiter solo en la ruta de login
router.post('/login', loginLimiter, async (req, res) => {
  // Tu l√≥gica de autenticaci√≥n aqu√≠
});

En frontend
    const response = await fetch(`${VITE_BACKEND_URL_RENDER}/api/v1/erroak/login`,
        {
            method: 'POST',
            credentials: 'include', // IMPORTANTE: esto permite usar la cookie
            headers: {'Content-type': 'application/json; charset=UTF-8'},
            body: JSON.stringify(user)
        }
    )
    const data = await response.json()
    if (response.status === 429) {
        // const data = await response.json();
        setErrorMessage(data.message || 'Demasiados intentos. Intente de nuevo m√°s tarde.')
        return
    }
    console.log("Respuesta backend: ", data)
    if (data.result === "No encontrado") {
...............
    }

Usando el siguiente codigo
    keyGenerator: (req, res) => {
    const user = req.body?.usuario || 'anon';
    return `${req.ip}-${user}`;
    },
Esto evita que un atacante desde una sola IP pruebe usuarios distintos ilimitadamente.

***************************************
Limitar el n√∫mero de solicitudes API (rate limiting)
***************************************
Limitar el N√∫mero de Solicitudes (Rate Limiting)

Al igual que con los ataques de fuerza bruta, puedes aplicar rate limiting en todas las rutas o en rutas espec√≠ficas de 
tu API. Esto no solo ayuda a prevenir ataques de fuerza bruta, sino que tambi√©n limita el impacto de un ataque DDoS al controlar el volumen de solicitudes por IP.

Ejemplo (en express claro):
    import rateLimit from 'express-rate-limit'; // PONER ANTES DE LOS ROUTER'S

app.use('/api/', apiLimiter); // Usar rate limiter en todas las rutas de la API

se puede combinar con authenticateToken si queremos meterlo en usuarios router tambi√©n ojo el orden, pero es mejor lo de arriba
router.post('/login', apiLimiter, authenticateToken, ...); // Usar rate limiter en una api en concreto, pero mejor en index.js

En middleware importado
const apiLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // reseteo del bloqueo cada 1 minuto
  max: 100, // Limitar a 100 solicitudes por IP por minuto
  message: "Demasiadas solicitudes. Por favor, intente nuevamente m√°s tarde.",
  standardHeaders: true,
  legacyHeaders: false,
});

A√±adir middleware en router usuarios.js
// L√≠mite espec√≠fico para registro .post('/usuario', ...)
export const registerLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hora
  max: 5, // m√°ximo 5 registros por IP en una hora
  message: {
    success: false,
    message: "Demasiadas solicitudes de registro. Intente m√°s tarde.",
  },
  standardHeaders: true,
  legacyHeaders: false,
})

*********************************
PROTECCI√ìN CONTRA ATAQUES CSRF
*********************************
¬øQu√© es un ataque CSRF?

Un ataque Cross-Site Request Forgery ocurre cuando un sitio malicioso hace que el navegador del usuario autenticado 
(con cookies v√°lidas) ejecute una acci√≥n en tu sitio sin su consentimiento.

Ejemplo cl√°sico:
<!-- Un atacante inserta esto en una p√°gina -->
<img src="https://tuapp.com/api/delete-account" />

‚û°Ô∏è Si el usuario est√° logueado y su cookie de sesi√≥n sigue activa, el navegador enviar√° la cookie autom√°ticamente, 
ejecutando esa acci√≥n peligrosa.
Por eso:
Tu servidor debe asegurarse de que cada petici√≥n sensible viene realmente de tu frontend leg√≠timo, no de un sitio externo.

¬øC√≥mo funciona csurf?
csurf usa el modelo cl√°sico ‚Äúdouble-submit cookie‚Äù o ‚Äúsynchronized token pattern‚Äù, seg√∫n tu configuraci√≥n.

üîπ En resumen:
Cuando un usuario carga tu app o se autentica, el servidor genera un token CSRF √∫nico.

Ese token se guarda:
En la sesi√≥n del usuario (por defecto).
Y se env√≠a al frontend (por JSON o cookie).

En cada petici√≥n POST, PUT, PATCH, o DELETE, el frontend debe enviar ese token de vuelta.
csurf compara el token recibido con el almacenado en la sesi√≥n.
Si coinciden ‚Üí ‚úÖ petici√≥n v√°lida.

Si no ‚Üí ‚ùå ataque bloqueado.

üîç Explicaci√≥n de lo que hace csurf
Etapa	                    Qu√© hace csurf
Inicializaci√≥n	            Genera un token secreto por usuario y lo guarda en req.session._csrfSecret.
Al llamar req.csrfToken()	Calcula un token p√∫blico firmado y lo devuelve al frontend.
En una petici√≥n POST	    Lee el token del body, query, o header (x-csrf-token) y lo compara.
Si no coincide	            Lanza un error EBADCSRFTOKEN.



En este caso porque tenemos frontend y backend en distintos dominios.
Tenemos configurado
    SameSite='none' y no Lax o Strict

Explicacion ataque CSRF
Un ataque CSRF (Cross-Site Request Forgery) ‚Äîen espa√±ol, falsificaci√≥n de petici√≥n en sitios cruzados‚Äî es un tipo de vulnerabilidad que afecta a aplicaciones web del lado del backend, y que permite a un atacante hacer que un usuario autenticado ejecute acciones no deseadas en un sitio web en el que est√° logueado.

üß† Ejemplo conceptual

Imagina que est√°s logueado en tu banco (banco.com) y, mientras tanto, visitas un sitio malicioso (malicio.us).
Este sitio contiene un formulario oculto que env√≠a una petici√≥n POST a:

https://banco.com/transferir


con los datos:

{
  "cuenta_destino": "12345678",
  "monto": 1000
}


Cuando tu navegador carga la p√°gina maliciosa, autom√°ticamente env√≠a esa petici√≥n con tus cookies de sesi√≥n, porque 
sigues autenticado en banco.com.
El backend del banco recibe la solicitud, ve que est√° autenticada (por las cookies), y realiza la transferencia sin 
sospechar que no fue el usuario quien la inici√≥.

‚öôÔ∏è C√≥mo funciona t√©cnicamente

El usuario inicia sesi√≥n en un sitio leg√≠timo ‚Üí obtiene una cookie de sesi√≥n.
El atacante prepara una p√°gina maliciosa que env√≠a peticiones HTTP al mismo dominio (por ejemplo, usando un formulario 
o una petici√≥n fetch).
El navegador del usuario env√≠a la cookie de sesi√≥n autom√°ticamente, haciendo que el backend piense que la solicitud es leg√≠tima.
El servidor ejecuta la acci√≥n no deseada (p. ej., cambio de contrase√±a, transferencia, eliminaci√≥n de cuenta‚Ä¶).
üõ°Ô∏è C√≥mo se previene en el backend

Tokens CSRF (anti-CSRF tokens)
El backend genera un token √∫nico y lo env√≠a al frontend (por ejemplo, en un campo oculto del formulario o en el 
encabezado de la respuesta).
El frontend debe incluir ese token en cada solicitud que modifique datos (POST, PUT, DELETE...).
Si el token no coincide, el backend rechaza la solicitud.

Cabeceras personalizadas (en APIs)
Las peticiones leg√≠timas usan cabeceras especiales (como X-CSRF-Token o X-Requested-With).
Navegadores no env√≠an esas cabeceras autom√°ticamente, as√≠ que los ataques CSRF no pueden replicarlas.

SameSite cookies
Configurar la cookie de sesi√≥n con SameSite=Lax o Strict evita que se env√≠e autom√°ticamente desde otros dominios.

Validar origen y referer
El servidor puede comprobar las cabeceras Origin o Referer para asegurarse de que la solicitud proviene del dominio esperado.

üìã En resumen
Elemento	Descripci√≥n
Tipo de ataque	Cross-Site Request Forgery
Afecta a	Backends que conf√≠an solo en cookies/sesiones
Riesgo principal	Ejecuci√≥n de acciones sin consentimiento del usuario
Prevenci√≥n	Tokens CSRF, SameSite cookies, validaci√≥n de origen


EN NUESTRO CASO
Ya que usamos cookies HttpOnly cross-domain, la opci√≥n CSRF token (Double Submit Cookie) es la m√°s segura.

Comb√≠nalo con:
Rate limiting (ya lo tienes)
Verificaci√≥n de origin/referer como capa extra
SameSite cookies en endpoints internos si es posible

Opci√≥n: CSRF Tokens (Double Submit Cookie)
Backend genera un token CSRF diferente del JWT.
Se env√≠a al frontend (puede ser en una cookie normal o en la respuesta JSON).
Frontend lo env√≠a en cada request sensible, en un header como X-CSRF-Token.
Backend valida que el token coincida.

Ejemplo con Express y csurf:

import csurf from 'csurf';
import cookieParser from 'cookie-parser';

app.use(cookieParser());

const csrfProtection = csurf({
  cookie: {
    httpOnly: false, // accesible desde frontend
    sameSite: 'strict'
  }
});

app.get('/csrf-token', csrfProtection, (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

app.post('/update-profile', csrfProtection, (req, res) => {
  res.send('Perfil actualizado');
});


El frontend obtiene el token de /csrf-token (recomendado ponderlo en app.jsx)
  useEffect(() => {
    fetch('https://backend.com/csrf-token', {
      credentials: 'include'
    })
      .then(res => res.json())
      .then(data => {
        console.log('CSRF Token:', data.csrfToken);
        setCsrfToken(data.csrfToken);
      })
      .catch(err => console.error('Error obteniendo CSRF:', err));
  }, []);


y lo env√≠a en un header:

fetch('https://backend.com/update-profile', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken
  },
  body: JSON.stringify({ name: 'Juan' })
});

Mas ejemplos
EJEMPLO1 (USADO en mi app)
***********************************
Una implementaci√≥n manual de CSRF (con crypto.randomBytes) en lugar de csurf, para que vieras claramente el flujo 
completo y c√≥mo integrarlo con JWT HttpOnly + frontend separado.

Pero si quieres una versi√≥n m√°s robusta y autom√°tica, podemos integrar csurf perfectamente.
Te explico ambos enfoques y luego te dejo el c√≥digo completo con csurf.

‚öñÔ∏è Diferencias entre csurf y una soluci√≥n manual
Enfoque	Ventajas	Desventajas
üîπ Manual (como el ejemplo anterior)	Control total, f√°cil de combinar con JWT y frontends SPA; no dependes de sesiones.	
    Tienes que implementar la validaci√≥n t√∫ mismo.
üîπ csurf middleware	Autom√°tico, probado y s√≥lido; maneja tokens, cookies y validaci√≥n.	Originalmente dise√±ado para apps 
    con sessions (Express-session); con JWT hay que adaptarlo.


üí° C√≥mo usar csurf con JWT (sin sesiones)
Por defecto, csurf guarda el token en la sesi√≥n (req.session.csrfSecret).
Pero como t√∫ usas JWT (sin sesiones), debemos configurarlo para que guarde el secreto en una cookie.

As√≠, csurf:
    Genera un token CSRF basado en ese secreto.
    Lo env√≠a al frontend.
    Valida autom√°ticamente el header X-CSRF-Token en cada request protegida.
üîç Explicaci√≥n de lo que hace csurf
Etapa	                    Qu√© hace csurf
Inicializaci√≥n	            Genera un token secreto por usuario y lo guarda en req.session._csrfSecret.
Al llamar req.csrfToken()	Calcula un token p√∫blico firmado y lo devuelve al frontend.
En una petici√≥n POST	    Lee el token del body, query, o header (x-csrf-token) y lo compara.
Si no coincide	            Lanza un error EBADCSRFTOKEN.



üß© BACKEND con csurf
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import csurf from 'csurf';

dotenv.config();
const app = express();

app.use(express.json());
app.use(cookieParser());
app.use(cors({
  origin: 'https://frontend.com',
  credentials: true,
}));

// Middleware de autenticaci√≥n
function authMiddleware(req, res, next) {
  const token = req.cookies.token;
  if (!token) return res.status(401).json({ message: 'No token' });
  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET);
    next();
  } catch {
    res.status(401).json({ message: 'Token inv√°lido' });
  }
}

// Configurar csurf con cookie (sin sesiones)
const csrfProtection = csurf({
  cookie: {
    key: '_csrfSecret',  // cookie donde guarda el secreto
    httpOnly: true,      // no accesible desde JS
    sameSite: 'none',
    secure: true,
  },
});

// üîπ Endpoint para obtener el token CSRF
app.get('/csrf-token', csrfProtection, (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

// üîπ Login (genera JWT)
app.post('/login', (req, res) => {
  const { username } = req.body;
  const jwtToken = jwt.sign({ username }, process.env.JWT_SECRET, { expiresIn: '1h' });

  res.cookie('token', jwtToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'none',
    maxAge: 60 * 60 * 1000,
  });

  res.json({ success: true });
});

// üîπ Ruta protegida con JWT + CSRF
app.post('/update-profile', authMiddleware, csrfProtection, (req, res) => {
  res.json({ message: `Perfil de ${req.user.username} actualizado correctamente.` });
});

// üîπ Logout
app.post('/logout', (req, res) => {
  res.clearCookie('token', { sameSite: 'none', secure: true });
  res.clearCookie('_csrfSecret', { sameSite: 'none', secure: true });
  res.json({ success: true });
});

app.listen(4000, () => console.log('‚úÖ Backend con csurf activo'));

‚öõÔ∏è FRONTEND (React)

Tu flujo sigue igual, solo que ahora el CSRF lo pides con /csrf-token:

async function getCSRFToken() {
  const res = await fetch('https://backend.com/csrf-token', {
    credentials: 'include',
  });
  const data = await res.json();
  return data.csrfToken;
}

// Ejemplo de uso
const csrfToken = await getCSRFToken();

await fetch('https://backend.com/update-profile', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken,
  },
  body: JSON.stringify({ name: 'Nuevo nombre' }),
});

üîê Qu√© hace autom√°ticamente csurf

‚úÖ Genera un secreto por usuario y lo guarda en una cookie HttpOnly (_csrfSecret).
‚úÖ Crea un token firmado √∫nico (req.csrfToken()) que el frontend debe enviar.
‚úÖ Valida autom√°ticamente ese token en cada request protegida.
‚úÖ Si el token no coincide, lanza error 403 (EBADCSRFTOKEN).

üß© Combinaci√≥n recomendada

JWT en cookie HttpOnly ‚Üí autentica al usuario.

csurf con cookie propia ‚Üí valida intenci√≥n del usuario.

cors con credentials: true ‚Üí permite cookies cross-domain.

EJEMPLO2
**********************************************
el backend regenerar√° el token CSRF autom√°ticamente al hacer login y lo invalidar√° o renovar√° al hacer logout.
As√≠, tu frontend no necesita pedirlo manualmente ‚Äî solo lo actualiza cuando cambia el estado de autenticaci√≥n.

üß± Objetivo del flujo

Usuario entra ‚Üí si no hay sesi√≥n, no hay token CSRF.

Usuario hace login ‚Üí backend crea:

JWT en cookie HttpOnly

CSRF token (en JSON o cookie accesible)

Usuario hace peticiones autenticadas ‚Üí env√≠a X-CSRF-Token.

Usuario hace logout ‚Üí backend borra cookie JWT y genera un nuevo CSRF token ‚Äúvac√≠o‚Äù (o inv√°lido).

üß© BACKEND (Express)
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import crypto from 'crypto'; // para generar tokens CSRF simples

dotenv.config();
const app = express();

app.use(express.json());
app.use(cookieParser());
app.use(cors({
  origin: 'https://frontend.com',
  credentials: true,
}));

// Middleware de autenticaci√≥n JWT
function authMiddleware(req, res, next) {
  const token = req.cookies.token;
  if (!token) return res.status(401).json({ message: 'No token' });
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch {
    res.status(401).json({ message: 'Token inv√°lido' });
  }
}

// Generar CSRF token seguro (simple y r√°pido)
function generateCSRFToken() {
  return crypto.randomBytes(32).toString('hex');
}

// LOGIN ‚Äî genera JWT + CSRF
app.post('/login', (req, res) => {
  const { username } = req.body;
  const jwtToken = jwt.sign({ username }, process.env.JWT_SECRET, { expiresIn: '1h' });
  const csrfToken = generateCSRFToken();

  // Guardar CSRF token vinculado al usuario (ejemplo simple, en memoria o DB)
  // Aqu√≠, para demo, lo devolvemos directamente
  res.cookie('token', jwtToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'none',
    maxAge: 60 * 60 * 1000,
  });

  // Enviar el CSRF token al frontend
  res.json({ csrfToken });
});

// Ruta protegida
app.post('/update-profile', authMiddleware, (req, res) => {
  const clientCSRF = req.headers['x-csrf-token'];
  if (!clientCSRF) return res.status(403).json({ message: 'Falta CSRF token' });

  // Aqu√≠ podr√≠as validar el token guardado en DB o en sesi√≥n si lo implementas
  // (para este ejemplo asumimos que es v√°lido)
  res.json({ message: `Perfil de ${req.user.username} actualizado correctamente.` });
});

// LOGOUT ‚Äî borra JWT y renueva CSRF vac√≠o
app.post('/logout', (req, res) => {
  res.clearCookie('token', { sameSite: 'none', secure: true });
  const newCSRF = generateCSRFToken(); // token nuevo, sin sesi√≥n activa
  res.json({ csrfToken: newCSRF });
});

app.listen(4000, () => console.log('‚úÖ Backend seguro en http://localhost:4000'));

‚öõÔ∏è FRONTEND (React)
AuthContext.jsx

Guarda el CSRF token y lo actualiza en login/logout autom√°ticamente üëá

import { createContext, useContext, useState } from 'react';

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [csrfToken, setCsrfToken] = useState('');
  const [user, setUser] = useState(null);

  async function login(username) {
    const res = await fetch('https://backend.com/login', {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username }),
    });
    const data = await res.json();
    setCsrfToken(data.csrfToken);
    setUser(username);
  }

  async function logout() {
    const res = await fetch('https://backend.com/logout', {
      method: 'POST',
      credentials: 'include',
    });
    const data = await res.json();
    setUser(null);
    setCsrfToken(data.csrfToken); // ‚ö° Nuevo token (sin sesi√≥n)
  }

  return (
    <AuthContext.Provider value={{ user, csrfToken, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  return useContext(AuthContext);
}

Ejemplo de uso (App.jsx)
import { useAuth } from './AuthContext';

export default function App() {
  const { user, csrfToken, login, logout } = useAuth();

  async function updateProfile() {
    const res = await fetch('https://backend.com/update-profile', {
      method: 'POST',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken,
      },
      body: JSON.stringify({ name: 'Nuevo nombre' }),
    });
    const data = await res.json();
    alert(data.message);
  }

  return (
    <div>
      <h1>Hola {user || 'invitado'}</h1>
      {!user ? (
        <button onClick={() => login('juan')}>Login</button>
      ) : (
        <>
          <button onClick={logout}>Logout</button>
          <button onClick={updateProfile}>Actualizar perfil</button>
        </>
      )}
    </div>
  );
}

üîê Resumen del flujo
Acci√≥n	Backend hace	Frontend hace
Login	Crea JWT + nuevo CSRF token	Guarda token en memoria
Request protegida	Valida JWT y CSRF	Env√≠a header X-CSRF-Token
Logout	Borra cookie JWT + genera CSRF vac√≠o	Limpia usuario y actualiza token



**********************************************
EJEMPLO3 (OJO CSURF esta deprecated, osea obsoleto)
**********************************************
Instalar csurf
npm install csurf

2Ô∏è‚É£ Configurar middleware CSRF en index.js o tu main server
import express from 'express';
import cookieParser from 'cookie-parser';
import csurf from 'csurf';
import usuariosRouter from './routes/usuarios.js';

const app = express();

app.use(express.json());
app.use(cookieParser());

// Configuraci√≥n CSRF
const csrfProtection = csurf({
    cookie: {
        httpOnly: true,
        secure: true,       // si usas HTTPS
        sameSite: 'none',   // porque tu frontend est√° en otro dominio
    }
});

// Endpoint para obtener token CSRF
app.get('/api/v1/erroak/csrf-token', csrfProtection, (req, res) => {
    res.json({ csrfToken: req.csrfToken() });
});

// Aplicar csrfProtection solo a rutas que modifican datos
app.use('/api/v1/erroak', usuariosRouter);

export default app;


Nota: solo protegemos rutas POST, PUT, DELETE que cambian datos; GET no necesita CSRF.

3Ô∏è‚É£ Integrar CSRF en tu router (usuarios.js)

Primero, importa el middleware:

import csurf from 'csurf';
const csrfProtection = csurf({ cookie: true });


Luego aplica csrfProtection a rutas que modifican datos. Ejemplo:

// Crear usuario
router.post('/usuario', registerLimiter, csrfProtection, async(req, res) => {
    const usuario = req.body;
    const resultUsuario = await postUsuario(usuario);
    res.json(resultUsuario);
});

// Actualizar usuario
router.put('/usuario/:id', updateUserLimiter, authenticateToken, csrfProtection, async(req, res) => {
    const id = req.params.id;
    const updatedUser = req.body;
    const result = await putUsuario(id, updatedUser);
    res.json(result);
});

// Logout (limpia cookie CSRF tambi√©n)
router.post('/logout', authenticateToken, csrfProtection, (req, res) => {
    res.clearCookie('token', { httpOnly: true, secure: true, sameSite: 'none' });
    res.clearCookie('_csrf'); // limpiar cookie CSRF
    res.json({ message: 'Sesi√≥n cerrada' });
});


Las rutas GET (/usuarios, /me, /usuario/:id, /getsignupformdata) no requieren CSRF.

4Ô∏è‚É£ En el frontend React

Obtener token CSRF al cargar la app:

async function fetchCsrfToken() {
    const res = await fetch('https://tu-backend.com/api/v1/erroak/csrf-token', {
        credentials: 'include', // env√≠a cookies
    });
    const data = await res.json();
    return data.csrfToken;
}


Enviar el token en headers en cada POST/PUT/DELETE:

const csrfToken = await fetchCsrfToken();

fetch('https://tu-backend.com/api/v1/erroak/usuario', {
    method: 'POST',
    credentials: 'include', // cookies httpOnly
    headers: {
        'Content-Type': 'application/json',
        'csrf-token': csrfToken // CSRF token obligatorio
    },
    body: JSON.stringify(usuario)
});

‚úÖ Beneficios de este setup

Mantienes JWT httpOnly para proteger contra XSS.

A√±ades protecci√≥n CSRF para POST/PUT/DELETE.

No necesitas mover JWT al header Authorization si quieres mantener cookies.

Compatible con frontend en otro dominio (sameSite: 'none', secure: true).


******************************
EJEMPLO4
******************************

csrf-sync
    es una opci√≥n moderna y m√°s flexible que csurf, especialmente cuando trabajas con JWT + cookies HttpOnly + frontend separado (SPA).

Vamos a ver por qu√©, y te dejo luego el c√≥digo completo para integrarlo en tu backend actual (usuarios.js + index.js).

üí° ¬øPor qu√© csrf-sync en lugar de csurf?
Caracter√≠stica	                            csurf	                                   csrf-sync
Requiere express-session	                S√≠ (por defecto)	                       ‚ùå No
Compatible con JWT + cookies	            üü° Requiere configuraci√≥n extra	           ‚úÖ Totalmente compatible
F√°cil de usar en SPA (React, Vue, etc.) 	üü° Necesita endpoint /csrf-token manual	   ‚úÖ Integrado y simple
Genera/verifica token	                    Autom√°tico (por cookie)	                    Autom√°tico (por cookie o memoria)
Ideal para microservicios / APIs	        ‚ùå	                                      ‚úÖ

üëâ En tu caso ‚Äîbackend JWT HttpOnly + frontend separado (React)‚Äî csrf-sync es la mejor opci√≥n.

üß± Instalaci√≥n
npm install csrf-sync

‚öôÔ∏è Configuraci√≥n en tu index.js

Aqu√≠ configuramos el middleware global para Express.

// index.js
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import { csrfSync } from 'csrf-sync';
import usuariosRouter from './routes/usuarios.js';
import dotenv from 'dotenv';
dotenv.config();

const app = express();

app.use(express.json());
app.use(cookieParser());
app.use(cors({
  origin: [
    'http://localhost:5173',
    'https://calendar2-6wyj.onrender.com'
  ],
  credentials: true
}));

// üîê Inicializar csrf-sync
const { csrfSynchronisedProtection, generateToken } = csrfSync({
  getTokenFromRequest: (req) => req.headers['x-csrf-token'],
  cookieName: '_csrf', // cookie segura
  cookieOptions: {
    httpOnly: true,
    secure: true,
    sameSite: 'none',
  },
});

// Endpoint para obtener el token CSRF
app.get('/api/v1/erroak/csrf-token', (req, res) => {
  const token = generateToken(req);
  res.json({ csrfToken: token });
});

// Aplicar protecci√≥n CSRF solo despu√©s de /csrf-token
// As√≠, las rutas protegidas deben enviar `X-CSRF-Token`
app.use(csrfSynchronisedProtection);

// Rutas
app.use('/api/v1/erroak', usuariosRouter);

// Start server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`‚úÖ Server running on http://localhost:${PORT}`));

üß© En tu router /routes/usuarios.js

No necesitas tocar casi nada ‚Äî solo aseg√∫rate de enviar el token CSRF desde el frontend cuando hagas peticiones POST/PUT/DELETE.

Tus rutas pueden quedar as√≠:

import { Router } from 'express';
import { authenticateToken, loginLimiter, registerLimiter } from '../middleware/login.js';
import { postUsuario, postLogin, postMe, getUsuarios, getUsuario } from '../models/usuariosModel.js';

const router = Router();

// ‚úÖ Login
router.post('/login', loginLimiter, async (req, res) => {
  const loginDetails = req.body;
  const login = await postLogin(loginDetails);
  if (login.success) {
    res.cookie('token', login.token, {
      httpOnly: true,
      secure: true,
      sameSite: 'none'
    });
  }
  res.json(login);
});

// ‚úÖ Crear usuario (protegido CSRF + rate limit)
router.post('/usuario', registerLimiter, async (req, res) => {
  const usuario = req.body;
  const result = await postUsuario(usuario);
  res.json(result);
});

// ‚úÖ Logout (limpia cookie JWT + CSRF)
router.post('/logout', authenticateToken, (req, res) => {
  res.clearCookie('token', { httpOnly: true, secure: true, sameSite: 'none' });
  res.clearCookie('_csrf', { httpOnly: true, secure: true, sameSite: 'none' });
  res.json({ message: 'Sesi√≥n cerrada' });
});

// ‚úÖ Datos de usuario autenticado
router.get('/usuario', authenticateToken, async (req, res) => {
  const id = req.user.usuarioID;
  const result = await getUsuario(id);
  res.json(result);
});

export default router;

‚öõÔ∏è En el frontend React

Pedir el token CSRF al iniciar la app o antes del primer POST:

async function getCsrfToken() {
  const res = await fetch('https://tu-backend.com/api/v1/erroak/csrf-token', {
    credentials: 'include'
  });
  const data = await res.json();
  return data.csrfToken;
}


Enviar el token en cada request que cambie datos:

const csrfToken = await getCsrfToken();

await fetch('https://tu-backend.com/api/v1/erroak/usuario', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken
  },
  body: JSON.stringify({ email, password, nombre_apellidos })
});

üîí Ventajas de esta implementaci√≥n

‚úÖ No necesitas sesiones (express-session) ‚Äî compatible con JWT.
‚úÖ Compatible con frontends SPA en otros dominios (sameSite: 'none').
‚úÖ Tokens sincronizados entre cookie HttpOnly y header.
‚úÖ Simple de integrar y mantener.
‚úÖ Requiere una sola petici√≥n inicial /csrf-token por sesi√≥n o al refrescar.

üöÄ Flujo completo
Etapa	            Acci√≥n	            Qu√© ocurre
App carga	        GET /csrf-token 	Backend genera token y setea cookie _csrf
Login	            POST /login	        Backend crea cookie JWT
Petici√≥n protegida	POST /usuario, etc.	Frontend env√≠a header X-CSRF-Token; backend valida
Logout	            POST /logout	    Se limpian cookies JWT y CSRF


El paquete csrf-sync
 guarda los tokens CSRF dentro de req.session, o en un ‚Äúalmacenamiento‚Äù asociado a la sesi√≥n.
Si no existe req.session (porque nunca se configur√≥ express-session), no tiene d√≥nde guardar ni recuperar el token, y lanza el error:

TypeError: Cannot read properties of undefined (reading 'csrfToken')

npm install express-session

C√≥mo se usa express-session

Inst√°lalo:

npm install express-session


Luego, en tu index.js, lo colocas antes de csrf-sync:

import session from 'express-session'
import { csrfSync } from 'csrf-sync'

app.use(session({
  secret: process.env.SESSION_SECRET || 'clave-secreta-supersegura',
  resave: false,
  saveUninitialized: true,
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'none',
  }
}));

// Ahora que hay sesi√≥n, csrf-sync puede usarla
const { csrfSynchronisedProtection, generateToken } = csrfSync({
  getTokenFromRequest: (req) => req.headers['x-csrf-token'],
});

// Endpoint p√∫blico para obtener el token CSRF
app.get('/api/v1/erroak/csrf-token', (req, res) => {
  const { csrfToken } = generateToken(req);
  res.json({ csrfToken });
});

// Aplica la protecci√≥n CSRF despu√©s del endpoint de token
app.use(csrfSynchronisedProtection);

En resumen
Concepto	Qu√© hace
express-session	Crea un objeto req.session para cada usuario y lo persiste entre peticiones mediante una cookie
csrf-sync	Usa req.session para guardar y verificar tokens CSRF sincronizados
Tu error actual	Ocurre porque req.session no existe; csrf-sync intenta acceder a √©l y falla


**********************
**********************
EJEMPLO 5 (FINAL)
**********************
Perfecto ‚úÖ ‚Äî actualmente est√°s usando csurf, que es un middleware cl√°sico para protecci√≥n CSRF, pero quieres migrar a csrf-sync
(QUE ESTA OBSOLETO), una alternativa m√°s moderna y simple (que no depende de sesiones o cookies de secreto).

Vamos a ver c√≥mo hacerlo paso a paso:

üöÄ Objetivo

Reemplazar csurf por csrf-sync, manteniendo tu mismo flujo:

Backend con Express.

JWT en cookie token.

CSRF token entregado v√≠a endpoint /csrf-token.

Protecci√≥n en rutas POST, usando encabezado o body.

üß© 1. Instala csrf-sync
npm install csrf-sync

üß† 2. Configura csrf-sync en lugar de csurf

En tu servidor, reemplaza las partes relacionadas con csurf por lo siguiente:

import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import { csrfSync } from 'csrf-sync';

dotenv.config();
const app = express();

app.use(express.json());
app.use(cookieParser());
app.use(cors({
  origin: 'https://frontend.com',
  credentials: true,
}));

// üß© Configurar csrf-sync
const {
  generateToken,    // genera un token por usuario
  validateToken,    // valida el token recibido
  invalidCsrfTokenError, // error lanzado si el token no es v√°lido
  getTokenFromHeaders,   // helper para leer encabezados
} = csrfSync({
  getTokenFromRequest: (req) => req.headers['x-csrf-token'], // c√≥mo lo env√≠a el frontend
});

// üß± Middleware de autenticaci√≥n
function authMiddleware(req, res, next) {
  const token = req.cookies.token;
  if (!token) return res.status(401).json({ message: 'No token' });
  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET);
    next();
  } catch {
    res.status(401).json({ message: 'Token inv√°lido' });
  }
}

// üîπ Endpoint para obtener el token CSRF
app.get('/csrf-token', (req, res) => {
  const csrfToken = generateToken(req);
  res.json({ csrfToken });
});

// üîπ Middleware para validar CSRF (solo en rutas sensibles)
function csrfProtection(req, res, next) {
  try {
    validateToken(req);
    next();
  } catch (err) {
    if (err === invalidCsrfTokenError) {
      return res.status(403).json({ message: 'Token CSRF inv√°lido o ausente' });
    }
    next(err);
  }
}

// üîπ Login (genera JWT)
app.post('/login', (req, res) => {
  const { username } = req.body;
  const jwtToken = jwt.sign({ username }, process.env.JWT_SECRET, { expiresIn: '1h' });

  res.cookie('token', jwtToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'none',
    maxAge: 60 * 60 * 1000,
  });

  res.json({ success: true });
});

// üîπ Ruta protegida con JWT + CSRF
app.post('/update-profile', authMiddleware, csrfProtection, (req, res) => {
  res.json({ message: `Perfil de ${req.user.username} actualizado correctamente.` });
});

// üîπ Logout
app.post('/logout', (req, res) => {
  res.clearCookie('token', { sameSite: 'none', secure: true });
  res.json({ success: true });
});

app.listen(4000, () => console.log('‚úÖ Backend con csrf-sync activo'));

üí° 3. En el frontend

Cuando obtienes el token CSRF (por ejemplo desde /csrf-token), lo guardas (en memoria, no en cookies) y lo env√≠as en el header X-CSRF-Token en cada petici√≥n POST/PUT/DELETE.

const res = await fetch('https://backend.com/csrf-token', { credentials: 'include' });
const { csrfToken } = await res.json();

await fetch('https://backend.com/update-profile', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken,
  },
  body: JSON.stringify({ ...data }),
});

‚öôÔ∏è 4. Diferencias clave entre csurf y csrf-sync
Caracter√≠stica	csurf	csrf-sync
Basado en cookie/sesi√≥n	S√≠	No
Ideal para APIs sin sesi√≥n	‚ùå	‚úÖ
Requiere middleware de sesi√≥n	A veces s√≠	No
Generaci√≥n manual del token	Menos flexible	Muy flexible
Soporte TypeScript	Limitado	Excelente

b√°sicamente con ese c√≥digo ya basta para reemplazar csurf por csrf-sync en tu backend.
El flujo completo (emisi√≥n y validaci√≥n del token) ya est√° cubierto con esas pocas l√≠neas.

Pero d√©jame puntualizar qu√© cosas son esenciales y cu√°les opcionales, para que sepas si ‚Äúbasta‚Äù depende de tu caso üëá

‚úÖ Esencial (lo m√≠nimo que necesitas)

Lo que ya tienes es suficiente para un backend funcional y seguro:

Importar y configurar csrfSync:

const { generateToken, validateToken, invalidCsrfTokenError } = csrfSync({
  getTokenFromRequest: (req) => req.headers['x-csrf-token'],
});


Endpoint para entregar el token CSRF:

app.get('/csrf-token', (req, res) => {
  res.json({ csrfToken: generateToken(req) });
});


Middleware para proteger rutas sensibles:

function csrfProtection(req, res, next) {
  try {
    validateToken(req);
    next();
  } catch (err) {
    if (err === invalidCsrfTokenError) {
      return res.status(403).json({ message: 'Token CSRF inv√°lido' });
    }
    next(err);
  }
}


Usarlo junto con tu authMiddleware:

app.post('/update-profile', authMiddleware, csrfProtection, (req, res) => {
  res.json({ message: 'Perfil actualizado.' });
});


Frontend env√≠a el token CSRF en cada request POST/PUT/DELETE:

fetch('/update-profile', {
  method: 'POST',
  credentials: 'include',
  headers: { 'X-CSRF-Token': csrfToken },
  body: JSON.stringify(data),
});

‚öôÔ∏è Opcional (solo si lo necesitas)

Persistencia o cach√© de tokens: por defecto csrf-sync los guarda en memoria, lo cual est√° bien para un solo proceso.
Si tienes varias instancias del servidor (cluster o load balancer), deber√≠as usar una opci√≥n de almacenamiento compartido (Redis, por ejemplo).

Refrescar el token autom√°ticamente: si tu frontend usa un framework SPA (React, Vue, etc.), podr√≠as pedir un nuevo /csrf-token al cargar o antes de cada acci√≥n protegida.

Validaci√≥n personalizada: puedes cambiar getTokenFromRequest para aceptar el token desde body o query si lo prefieres.

‚úÖ En resumen

S√≠, basta con el c√≥digo que te mostr√©.
Con eso reemplazas csurf completamente y mantienes el mismo nivel de seguridad CSRF, pero sin depender de cookies secretas ni sesiones.

*************************
*************************
OJO
*************************
    pero antes mostraste c√≥digo con csrf-sync sin necesidad de session
Excelente observaci√≥n üëè
Tienes toda la raz√≥n ‚Äî csrf-sync puede usarse sin express-session, pero solo si configuras manualmente c√≥mo almacena el token por usuario.
Si no se lo indicas, por defecto intenta usar req.session, y ah√≠ es donde te lanza el error:

TypeError: Cannot read properties of undefined (reading 'csrfToken')

üß† Explicaci√≥n clara

csrf-sync necesita alg√∫n ‚Äúestado‚Äù donde guardar el token sincronizado entre el cliente y el servidor.
Por defecto, ese ‚Äúestado‚Äù es req.session.
Si no usas sesiones, tienes que indicarle t√∫ c√≥mo mantener ese token.

‚úÖ Soluci√≥n sin express-session

Puedes decirle a csrf-sync que guarde el token directamente en una cookie firmada o simplemente en memoria (no recomendable para producci√≥n, pero √∫til para APIs sin estado).

Aqu√≠ te dejo una forma correcta sin sesiones, usando cookies:

üîß Ejemplo adaptado a tu c√≥digo
import express from "express";
import cookieParser from "cookie-parser";
import cors from "cors";
import { csrfSync } from "csrf-sync";

const app = express();
app.use(cookieParser());
app.use(express.json());

const allowedOrigins = [
  'http://localhost:5173',
  'https://calendar2-6wyj.onrender.com'
];

app.use(cors({
  origin: (origin, callback) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Origen no permitido por CORS'));
    }
  },
  credentials: true
}));

// ‚öôÔ∏è Configurar csrf-sync SIN sesi√≥n
const {
  generateToken,
  validateToken,
  invalidCsrfTokenError,
  getTokenFromHeaders
} = csrfSync({
  getTokenFromRequest: (req) => req.headers['x-csrf-token'],
  // üí° Aqu√≠ definimos un "store" basado en cookies en lugar de session
  getTokenFromState: (req) => req.cookies._csrf,
  setTokenOnState: (req, res, token) => {
    res.cookie('_csrf', token, {
      httpOnly: true,
      sameSite: 'lax',
      secure: process.env.NODE_ENV === 'production',
    });
  }
});

// üìç Endpoint para generar y enviar token CSRF
app.get('/api/v1/erroak/csrf-token', (req, res) => {
  const csrfToken = generateToken(req, res);
  console.log("imprimo csrfToken:", csrfToken);
  res.json({ csrfToken });
});

// üìç Ejemplo de endpoint protegido por CSRF
app.post('/api/v1/erroak/test', validateToken, (req, res) => {
  res.json({ message: "Petici√≥n POST protegida por CSRF" });
});

// üü¢ Iniciar servidor
app.listen(5000, () => console.log("Server running on http://localhost:5000"));

üîë Claves del cambio
Funci√≥n	Antes (con sesiones)	Ahora (sin sesiones)
getTokenFromState	usa req.session.csrfToken (por defecto)	usa req.cookies._csrf
setTokenOnState	guarda en sesi√≥n	guarda en cookie
generateToken(req, res)	ahora tambi√©n pasa res	para que pueda setear la cookie
üöÄ Resultado

Ahora:

Cuando el cliente pide /api/v1/erroak/csrf-token, el servidor:

Genera un token.

Lo guarda en una cookie _csrf.

Lo devuelve tambi√©n en el JSON (para React, por ejemplo).

Cuando el cliente hace un POST:

Incluye el header x-csrf-token.

validateToken compara ese token con el de la cookie.

Si coinciden ‚Üí ‚úÖ √©xito.

Si no ‚Üí ‚ùå lanza invalidCsrfTokenError.