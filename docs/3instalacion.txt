npm create vite@latest frontend

cd frontend    
npm install    
npm run dev

npm i react-big-calendar

npm i date-fns

********

    git add .
    git commit -m "first commit"
    git remote add origin https://github.com/JasonRodriguezGarcia/calendar2.git
    git branch -M main
    git push -u origin main

***************

npm install @mui/material @emotion/react @emotion/styled @mui/icons-material
npm install @mui/x-date-pickers @date-io/date-fns

***************
npm install react-router-dom

***************

abrir el contenedor de docker de nuestro compose.yml (que ya est√° configurado con postgres-db y pg_admin)
    docker compose up -d

Ya tenemos funcionando en segundo plano la bbdd postgresql y pg_admin para su administraci√≥n
Para abrir la administracion de la bbdd con pg_admin, abrir en navegador
    http://localhost:5050/

postgresql
en navegador ponemos localhost:5050 y entramos en la interfaz de postgresql del fichero docker_composer
OJO AL ENTRAR SELECCIONAR EN ESPA√ëOL EN LA OPCION DE ABAJO
entrar con
    jasonrodriguezempleo@gmail.com
    postgres  (contrase√±a del fichero docker_composer)

dentro
    boton derecho en servers (a la izq)
    register - servidor
    en pesta√±a general
    nombre postgres
    conexion
    nombre postgres
    usuario: postgres
    contrase√±a : postgresj
    boton SALVAR

a la izq
    servers
        postgres
            Bases de datos
            Boton derecho en Bases de datos - crear - base de datos
            nombre: demo
            salvar
a la izq
dentro de SERVERS aparecer√° un icono de POSTGRES y lo abrimos 
bases de datos boton DERECHO - CREAR - BASE DE DATOS
Base de datos pondremos: demo
boton SALVAR


***************
fichero de mern_4 0leemeDia26Junio.txt con informaci√≥n de nginx

directorio de mern_4 my-express-app con indicaciones para montar contenedor con express
***************
Para que al dar F5 estando en cualquier ruta como pueda ser https://calendar2-6wyj.onrender.com/holidays el navegador
no nos devuelva NOT FOUND

En Render tenemos que configurar en frontend el apartado Redirect/Rewrite con los siguiente par√°metros
    - Usando react
        Source:	/
        Destination: /index.html
        Action:	Rewrite
    - Usando Vite
        Source:	/*
        Destination: /index.html
        Action:	Rewrite

***************
PARA ENV√çO DE CORREO ELECTRONICO DESDE BACKEND
EN BACKEND
    npm install @sendgrid/mail
DARSE ALTA EN SENDGRID (es twilio product)
Una vez logeado
CREAR API KEY en 
    SETTINGS - API KEY
Luego a√±adimos la direcci√≥n de correo origen del email
    SETTINGS
        sender autentication
        Aparecer√° una nueva pantalla en la que uno de los botones pondr√°
            VERIFY A SINGLE sender
            Lo que nos permitir√° meter una direcci√≥n de mail que usaremos como origen del email
            Que luego tendremos que verificar, lo cual haremos al crearla, ya recibiremos un email que tengremos que contestar
        Tambi√©n tendremos que hacer un domain autentication para que el receptor de los correos no reciba un aviso de 
        correo no verificado
            DOMAIN AUTHENTICACION
            Verifica el dominio en SendGrid
            Para que los correos no aparezcan como "NO VERIFICADO", debes verificar que el dominio erroak.sartu.org est√© autenticado en tu cuenta de SendGrid.
            Pasos:
            Entra en https://app.sendgrid.com/settings/sender_auth
            En la secci√≥n "Domain Authentication", haz clic en "Get Started".
            Selecciona tu proveedor de DNS (por ejemplo, Cloudflare, GoDaddy, etc.).
            Ingresa el dominio: erroak.sartu.org.
            SendGrid te dar√° varios registros DNS (como CNAME) que debes a√±adir en el panel DNS de tu dominio.
            Una vez a√±adidos, vuelve a SendGrid y haz clic en "Verify".
            ‚úÖ Importante: Este paso puede tardar un poco en propagarse (hasta 24h), pero normalmente es r√°pido.

            Otros pasos: (Parece lo mismo)
Si ya hiciste el Single Sender Verification y a√∫n ves ‚ÄúNO VERIFICADO‚Äù, esto es lo que est√° pasando:
Por qu√© sigue apareciendo ‚ÄúNO VERIFICADO‚Äù
Single Sender vs Dominio autenticado
La verificaci√≥n de remitente √∫nico solo confirma que SendGrid puede enviar correos desde esa direcci√≥n espec√≠fica, pero no 
cambia c√≥mo los clientes de correo validan el dominio.
Gmail, Outlook y Apple Mail verifican el dominio, no solo la direcci√≥n de correo.
Como el dominio no est√° autenticado con DKIM/SPF, los correos aparecen ‚Äúvia SendGrid‚Äù o ‚ÄúNO VERIFICADO‚Äù.
Cliente de correo estricto
Algunos clientes, como Gmail, muestran ‚ÄúNO VERIFICADO‚Äù incluso si el remitente est√° verificado en SendGrid, mientras no haya registros DKIM y SPF correctos.
C√≥mo eliminar el ‚ÄúNO VERIFICADO‚Äù
Para que desaparezca por completo, necesitas autenticar tu dominio (no solo un remitente √∫nico):
Ve a Settings ‚Üí Sender Authentication ‚Üí Authenticate Your Domain en SendGrid.
Introduce tu dominio propio (ej. midominio.com) y tu proveedor de DNS.
A√±ade los registros CNAME que SendGrid te da a tu DNS.
Espera la propagaci√≥n DNS (puede tardar minutos u horas).
Env√≠a un correo desde cualquier direcci√≥n de tu dominio autenticado, y Gmail/Outlook ya mostrar√°n tu dominio como verificado.

üí° Resumen:
    Single Sender Verification = env√≠os permitidos desde esa direcci√≥n, √∫til para pruebas.
    Domain Authentication = hace que tu dominio se vea verificado en todos los clientes de correo.
    Solo con domain authentication desaparece ‚ÄúNO VERIFICADO‚Äù de Gmail, Outlook, etc.

*********************
PENDING MIRAR !!! 
En express
    npm install express-validator (para velidaci√≥n de rutas)

express-validator es un paquete para Node.js que proporciona middlewares para validar y sanear datos de entrada en aplicaciones Express.js, permitiendo verificar que la informaci√≥n recibida en las peticiones (como el cuerpo, par√°metros o query strings) cumple ciertos criterios y transformarla para mejorar la seguridad. Se integra con la biblioteca validator.js y usa una "cadena" de validaciones para definir reglas para cada campo de datos. 
¬øC√≥mo funciona?
1. Validaci√≥n: express-validator permite definir reglas para cada campo que se espera en una petici√≥n. Por ejemplo, puedes especificar que un campo de email debe tener un formato de correo electr√≥nico v√°lido, o que un campo de contrase√±a debe tener una longitud m√≠nima. 
2. Saneamiento: Tambi√©n incluye funciones para "sanear" los datos, lo cual ayuda a prevenir ataques de seguridad. Esto puede incluir la limpieza de espacios en blanco o la conversi√≥n de tipos de datos. 
3. Middleware: Se integra como middleware en Express.js, lo que significa que se ejecuta antes de que la l√≥gica principal de tu ruta o controlador sea llamada. 
4. Resultados de la validaci√≥n: Si las validaciones fallan, express-validator devuelve un objeto con los errores, permitiendo enviarlos de vuelta al cliente o manejar la respuesta adecuadamente. 
Usos comunes
Validaci√≥n de formularios: Asegurar que los datos ingresados en formularios web son correctos antes de procesarlos en el backend. 
APIs: Verificar que los datos enviados a tu API cumplen los requisitos definidos, como la estructura de un JSON. 
Seguridad: Prevenir vulnerabilidades como la inyecci√≥n de c√≥digo al sanear los datos de entrada. 
Ejemplo r√°pido
JavaScript

const express = require('express');
const { body, validationResult } = require('express-validator'); // Importa body y validationResult

const app = express();

app.post('/registro', [
  // Reglas de validaci√≥n para los campos email y contrase√±a
  body('email').isEmail().withMessage('Por favor, introduce un email v√°lido'),
  body('password').isLength({ min: 5 }).withMessage('La contrase√±a debe tener al menos 5 caracteres'),
], (req, res) => {
  const errors = validationResult(req); // Captura los errores de validaci√≥n

  if (!errors.isEmpty()) {
    // Si hay errores, los devuelve al cliente
    return res.status(400).json({ errors: errors.array() });
  }

  // Si todo est√° bien, procede con la l√≥gica del registro
  // ...
});

app.listen(3000, () => console.log('Servidor en el puerto 3000'));
En este ejemplo, se usa body() para validar campos en el cuerpo de la petici√≥n, se comprueba que el email sea v√°lido y la password tenga al menos 5 caracteres. Si no, se devuelven los errores. 
*********************
