npm create vite@latest frontend

cd frontend    
npm install    
npm run dev

npm i react-big-calendar

npm i date-fns

********

    git add .
    git commit -m "first commit"
    git remote add origin https://github.com/JasonRodriguezGarcia/calendar2.git
    git branch -M main
    git push -u origin main

***************

npm install @mui/material @emotion/react @emotion/styled @mui/icons-material
npm install @mui/x-date-pickers @date-io/date-fns

***************
npm install react-router-dom

***************

abrir el contenedor de docker de nuestro compose.yml (que ya está configurado con postgres-db y pg_admin)
    docker compose up -d

Ya tenemos funcionando en segundo plano la bbdd postgresql y pg_admin para su administración
Para abrir la administracion de la bbdd con pg_admin, abrir en navegador
    http://localhost:5050/

postgresql
en navegador ponemos localhost:5050 y entramos en la interfaz de postgresql del fichero docker_composer
OJO AL ENTRAR SELECCIONAR EN ESPAÑOL EN LA OPCION DE ABAJO
entrar con
    jasonrodriguezempleo@gmail.com
    postgres  (contraseña del fichero docker_composer)

dentro
    boton derecho en servers (a la izq)
    register - servidor
    en pestaña general
    nombre postgres
    conexion
    nombre postgres
    usuario: postgres
    contraseña : postgresj
    boton SALVAR

a la izq
    servers
        postgres
            Bases de datos
            Boton derecho en Bases de datos - crear - base de datos
            nombre: demo
            salvar
a la izq
dentro de SERVERS aparecerá un icono de POSTGRES y lo abrimos 
bases de datos boton DERECHO - CREAR - BASE DE DATOS
Base de datos pondremos: demo
boton SALVAR


***************
fichero de mern_4 0leemeDia26Junio.txt con información de nginx

directorio de mern_4 my-express-app con indicaciones para montar contenedor con express
***************
Para que al dar F5 estando en cualquier ruta como pueda ser https://calendar2-6wyj.onrender.com/holidays el navegador
no nos devuelva NOT FOUND

En Render tenemos que configurar en frontend el apartado Redirect/Rewrite con los siguiente parámetros
    - Usando react
        Source:	/
        Destination: /index.html
        Action:	Rewrite
    - Usando Vite
        Source:	/*
        Destination: /index.html
        Action:	Rewrite

***************
PARA ENVÍO DE CORREO ELECTRONICO DESDE BACKEND
EN BACKEND
    npm install @sendgrid/mail
DARSE ALTA EN SENDGRID (es twilio product)
Una vez logeado
CREAR API KEY en 
    SETTINGS - API KEY
Luego añadimos la dirección de correo origen del email
    SETTINGS
        sender autentication
        Aparecerá una nueva pantalla en la que uno de los botones pondrá
            VERIFY A SINGLE sender
            Lo que nos permitirá meter una dirección de mail que usaremos como origen del email
            Que luego tendremos que verificar, lo cual haremos al crearla, ya recibiremos un email que tengremos que contestar
        También tendremos que hacer un domain autentication para que el receptor de los correos no reciba un aviso de 
        correo no verificado
            DOMAIN AUTHENTICACION
            Verifica el dominio en SendGrid
            Para que los correos no aparezcan como "NO VERIFICADO", debes verificar que el dominio erroak.sartu.org esté autenticado en tu cuenta de SendGrid.
            Pasos:
            Entra en https://app.sendgrid.com/settings/sender_auth
            En la sección "Domain Authentication", haz clic en "Get Started".
            Selecciona tu proveedor de DNS (por ejemplo, Cloudflare, GoDaddy, etc.).
            Ingresa el dominio: erroak.sartu.org.
            SendGrid te dará varios registros DNS (como CNAME) que debes añadir en el panel DNS de tu dominio.
            Una vez añadidos, vuelve a SendGrid y haz clic en "Verify".
            ✅ Importante: Este paso puede tardar un poco en propagarse (hasta 24h), pero normalmente es rápido.

*********************
PENDING MIRAR !!! 
En express
    npm install express-validator (para velidación de rutas)

express-validator es un paquete para Node.js que proporciona middlewares para validar y sanear datos de entrada en aplicaciones Express.js, permitiendo verificar que la información recibida en las peticiones (como el cuerpo, parámetros o query strings) cumple ciertos criterios y transformarla para mejorar la seguridad. Se integra con la biblioteca validator.js y usa una "cadena" de validaciones para definir reglas para cada campo de datos. 
¿Cómo funciona?
1. Validación: express-validator permite definir reglas para cada campo que se espera en una petición. Por ejemplo, puedes especificar que un campo de email debe tener un formato de correo electrónico válido, o que un campo de contraseña debe tener una longitud mínima. 
2. Saneamiento: También incluye funciones para "sanear" los datos, lo cual ayuda a prevenir ataques de seguridad. Esto puede incluir la limpieza de espacios en blanco o la conversión de tipos de datos. 
3. Middleware: Se integra como middleware en Express.js, lo que significa que se ejecuta antes de que la lógica principal de tu ruta o controlador sea llamada. 
4. Resultados de la validación: Si las validaciones fallan, express-validator devuelve un objeto con los errores, permitiendo enviarlos de vuelta al cliente o manejar la respuesta adecuadamente. 
Usos comunes
Validación de formularios: Asegurar que los datos ingresados en formularios web son correctos antes de procesarlos en el backend. 
APIs: Verificar que los datos enviados a tu API cumplen los requisitos definidos, como la estructura de un JSON. 
Seguridad: Prevenir vulnerabilidades como la inyección de código al sanear los datos de entrada. 
Ejemplo rápido
JavaScript

const express = require('express');
const { body, validationResult } = require('express-validator'); // Importa body y validationResult

const app = express();

app.post('/registro', [
  // Reglas de validación para los campos email y contraseña
  body('email').isEmail().withMessage('Por favor, introduce un email válido'),
  body('password').isLength({ min: 5 }).withMessage('La contraseña debe tener al menos 5 caracteres'),
], (req, res) => {
  const errors = validationResult(req); // Captura los errores de validación

  if (!errors.isEmpty()) {
    // Si hay errores, los devuelve al cliente
    return res.status(400).json({ errors: errors.array() });
  }

  // Si todo está bien, procede con la lógica del registro
  // ...
});

app.listen(3000, () => console.log('Servidor en el puerto 3000'));
En este ejemplo, se usa body() para validar campos en el cuerpo de la petición, se comprueba que el email sea válido y la password tenga al menos 5 caracteres. Si no, se devuelven los errores. 
*********************
