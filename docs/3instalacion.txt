npm create vite@latest frontend

cd frontend    
npm install    
npm run dev

npm i react-big-calendar

npm i date-fns

********

    git add .
    git commit -m "first commit"
    git remote add origin https://github.com/JasonRodriguezGarcia/calendar2.git
    git branch -M main
    git push -u origin main

***************

npm install @mui/material @emotion/react @emotion/styled @mui/icons-material
npm install @mui/x-date-pickers @date-io/date-fns

***************
npm install react-router-dom

***************

abrir el contenedor de docker de nuestro compose.yml (que ya est√° configurado con postgres-db y pg_admin)
    docker compose up -d

Ya tenemos funcionando en segundo plano la bbdd postgresql y pg_admin para su administraci√≥n
Para abrir la administracion de la bbdd con pg_admin, abrir en navegador
    http://localhost:5050/

postgresql
en navegador ponemos localhost:5050 y entramos en la interfaz de postgresql del fichero docker_composer
OJO AL ENTRAR SELECCIONAR EN ESPA√ëOL EN LA OPCION DE ABAJO
entrar con
    jasonrodriguezempleo@gmail.com
    postgres  (contrase√±a del fichero docker_composer)

dentro
    boton derecho en servers (a la izq)
    register - servidor
    en pesta√±a general
    nombre postgres
    conexion
    nombre postgres
    usuario: postgres
    contrase√±a : postgresj
    boton SALVAR

a la izq
    servers
        postgres
            Bases de datos
            Boton derecho en Bases de datos - crear - base de datos
            nombre: demo
            salvar
a la izq
dentro de SERVERS aparecer√° un icono de POSTGRES y lo abrimos 
bases de datos boton DERECHO - CREAR - BASE DE DATOS
Base de datos pondremos: demo
boton SALVAR


***************
fichero de mern_4 0leemeDia26Junio.txt con informaci√≥n de nginx

directorio de mern_4 my-express-app con indicaciones para montar contenedor con express
***************
***************

Para que al dar F5 estando en cualquier ruta como pueda ser https://calendar2-6wyj.onrender.com/holidays el navegador
no nos devuelva NOT FOUND

En Render tenemos que configurar en frontend el apartado Redirect/Rewrite con los siguiente par√°metros
    - Usando Vite
        Source:	/*
        Destination: /index.html
        Action:	Rewrite

Diferencia entre Redirect y Rewrite
üîÅ 1. Redirect (Redirecci√≥n)

Cambia la URL del navegador.
Le dice al navegador: "Ve a otra direcci√≥n"
El navegador recarga la p√°gina con la nueva URL.
Ejemplo:

Si alguien entra a tusitio.com/login
Lo rediriges a tusitio.com/iniciar-sesion
üëâ La URL cambia visiblemente
üëâ √ötil para redirecciones permanentes, migraci√≥n de rutas, etc.

üìù 2. Rewrite (Reescritura)
NO cambia la URL del navegador.
El servidor responde con otro archivo internamente, pero la URL se mantiene.

Ejemplo t√≠pico en SPAs (React, Vite, Vue):
Usuario entra a tusitio.com/dashboard
Render no encuentra un archivo /dashboard

Pero con la regla:
/* ‚Üí /index.html (Rewrite)
Render devuelve index.html, y React Router se encarga de mostrar la vista correcta.
üëâ Reglas de Rewrite son esenciales para Single Page Applications.
Las Redirect and Rewrite Rules (Reglas de redirecci√≥n y reescritura) son configuraciones que te permiten controlar 
c√≥mo un servidor maneja las URLs que le llegan.
Render (y otros servicios como Netlify o Vercel) las usan para saber qu√© hacer con cada ruta que visita el usuario.
Como Vite/React Router manejan las rutas del lado del cliente, el servidor debe siempre devolver index.html para 
cualquier ruta que NO sea un archivo real.

Por eso configuras:
Source	Destination	Action
/*	/index.html	Rewrite
‚úîÔ∏è ¬øPara qu√© sirve esto en la pr√°ctica?

Para que al recargar una p√°gina como /profile, no salga un 404.
Para que las rutas del frontend funcionen correctamente.
Para servir tu SPA desde un solo archivo inicial.



***************
PARA ENV√çO DE CORREO ELECTRONICO DESDE BACKEND
EN BACKEND
    npm install @sendgrid/mail
DARSE ALTA EN SENDGRID (es twilio product)
Una vez logeado
CREAR API KEY en 
    SETTINGS - API KEY
Luego a√±adimos la direcci√≥n de correo origen del email
    SETTINGS
        sender autentication
        Aparecer√° una nueva pantalla en la que uno de los botones pondr√°
            VERIFY A SINGLE sender
            Lo que nos permitir√° meter una direcci√≥n de mail que usaremos como origen del email
            Que luego tendremos que verificar, lo cual haremos al crearla, ya recibiremos un email que tengremos que contestar
        Tambi√©n tendremos que hacer un domain autentication para que el receptor de los correos no reciba un aviso de 
        correo no verificado
            DOMAIN AUTHENTICACION
            Verifica el dominio en SendGrid
            Para que los correos no aparezcan como "NO VERIFICADO", debes verificar que el dominio erroak.sartu.org est√© autenticado en tu cuenta de SendGrid.
            Pasos:
            Entra en https://app.sendgrid.com/settings/sender_auth
            En la secci√≥n "Domain Authentication", haz clic en "Get Started".
            Selecciona tu proveedor de DNS (por ejemplo, Cloudflare, GoDaddy, etc.).
            Ingresa el dominio: erroak.sartu.org.
            SendGrid te dar√° varios registros DNS (como CNAME) que debes a√±adir en el panel DNS de tu dominio.
            Una vez a√±adidos, vuelve a SendGrid y haz clic en "Verify".
            ‚úÖ Importante: Este paso puede tardar un poco en propagarse (hasta 24h), pero normalmente es r√°pido.

            Otros pasos: (Parece lo mismo)
Si ya hiciste el Single Sender Verification y a√∫n ves ‚ÄúNO VERIFICADO‚Äù, esto es lo que est√° pasando:
Por qu√© sigue apareciendo ‚ÄúNO VERIFICADO‚Äù
Single Sender vs Dominio autenticado
La verificaci√≥n de remitente √∫nico solo confirma que SendGrid puede enviar correos desde esa direcci√≥n espec√≠fica, pero no 
cambia c√≥mo los clientes de correo validan el dominio.
Gmail, Outlook y Apple Mail verifican el dominio, no solo la direcci√≥n de correo.
Como el dominio no est√° autenticado con DKIM/SPF, los correos aparecen ‚Äúvia SendGrid‚Äù o ‚ÄúNO VERIFICADO‚Äù.
Cliente de correo estricto
Algunos clientes, como Gmail, muestran ‚ÄúNO VERIFICADO‚Äù incluso si el remitente est√° verificado en SendGrid, mientras no haya registros DKIM y SPF correctos.
C√≥mo eliminar el ‚ÄúNO VERIFICADO‚Äù
A) Para que desaparezca por completo, necesitas autenticar tu dominio (no solo un remitente √∫nico):
Ve a Settings ‚Üí Sender Authentication ‚Üí Authenticate Your Domain en SendGrid.
Introduce tu dominio propio (ej. midominio.com) y tu proveedor de DNS.
A√±ade los registros CNAME que SendGrid te da a tu DNS.
Espera la propagaci√≥n DNS (puede tardar minutos u horas).
Env√≠a un correo desde cualquier direcci√≥n de tu dominio autenticado, y Gmail/Outlook ya mostrar√°n tu dominio como verificado.


B) Otra forma es poner:
    abrir https://dnschecker.org/ns-lookup.php
    en Enter Domain to Check NS Records: poner sartu.org y ENTER
    m√°s abajo aparecen resultados en Results for: SARTU.org
        Type    Domain Name     TTL     Address 
        NS      sartu.org       21600   ns4.cdmondns-01.org. ( 52.58.66.183  Check IP Blacklist )
                                        Owner: A100 ROW GmbH Germany  WHOIS  AS16509

        Type    Domain Name     TTL     Address 
        NS      sartu.org       21600   ns5.cdmondns-01.com. ( 52.59.146.62  Check IP Blacklist )
                                        Owner: A100 ROW GmbH Germany  WHOIS  AS16509
        Type    Domain Name     TTL     Address 
        NS      sartu.org       21600   ns1.cdmon.net. ( 35.189.106.232  Check IP Blacklist )
                                        Owner: Google LLC United Kingdom of Great Britain and Northern Ireland  WHOIS  AS396982
        Type    Domain Name     TTL     Address 
        NS      sartu.org       21600   ns2.cdmon.net. ( 35.195.57.29  Check IP Blacklist )
                                        Owner: Google LLC Belgium  WHOIS  AS396982
        Type    Domain Name     TTL     Address 
        NS      sartu.org       21600   ns3.cdmon.net. ( 35.157.47.125  Check IP Blacklist )
                                        Owner: A100 ROW GmbH Germany  WHOIS  AS16509
    Lo cual indica que Tu dominio sartu.org usa los nameservers de CDmon.
    El dominio sartu.org tiene los DNS gestionados en CDmon.

    Esto quiere decir:

    ‚û°Ô∏è Todo lo relacionado con SPF, DKIM, CNAME, MX‚Ä¶ debes configurarlo en el panel de CDmon.
    ‚û°Ô∏è SendGrid SOLO funcionar√° si a√±ades los registros en CDmon ‚Üí Zona DNS.

    ¬øQu√© debes hacer ahora?
        1Ô∏è‚É£ Entra en CDmon
            Panel:
            üëâ https://cdmon.com/es (aparece un n√∫mero telef√≥nico en la web)

            Accede con la cuenta que administra el dominio sartu.org.
        2Ô∏è‚É£ Busca la secci√≥n:
                ‚ÄúDNS‚Äù
                ‚ÄúEditor DNS‚Äù
                ‚ÄúGesti√≥n de zona DNS‚Äù
                ‚ÄúRegistros DNS‚Äù
                En CDmon normalmente se llama:
                ‚ÄúAdministrador de DNS‚Äù ‚Üí ‚ÄúZona DNS‚Äù
            √≥ algo as√≠ como:
                Dominios ‚Üí Mis Dominios
                Seleccionas sartu.org
                Entras a DNS & Dominios
                Luego a Administrador de DNS o Gesti√≥n de zona DNS
                Busca algo como:
                    ‚úî ‚Äú√Årea DNS‚Äù
                    ‚úî ‚ÄúRegistros DNS‚Äù
                    ‚úî ‚ÄúZona DNS‚Äù
                Ah√≠ es donde podr√°s a√±adir LOS RESULTADOS CNAME DE ABAJO EN ESTE FORMATO

        3Ô∏è‚É£ A√±ade los CNAME que SendGrid te dar√°
            Despu√©s de poner en SendGrid:
                DNS Host: Other
                Which DNS Host: CDmon
                Branding links: YES
                Domain: erroak.sartu.org
            CNAME RESULTADOS
                Type	Host                        Value
                CNAME	url9354.erroak.sartu.org	sendgrid.net	

                Type	Host                        Value
                CNAME	56270334.erroak.sartu.org	sendgrid.net	

                Type	Host                        Value
                CNAME	em1037.erroak.sartu.org	    u56270334.wl085.sendgrid.net	

                Type	Host                            Value
                CNAME	s1._domainkey.erroak.sartu.org	s1.domainkey.u56270334.wl085.sendgrid.net	

                Type	Host                            Value
                CNAME	s2._domainkey.erroak.sartu.org	s2.domainkey.u56270334.wl085.sendgrid.net	

                Type	Host                        Value
                TXT	    _dmarc.erroak.sartu.org	    v=DMARC1; p=none;	

                En CDmon:
                üëâ En "Nombre / Host / Alias"
                Debes poner solo lo que va antes del dominio:
                Datos a introducir Y AS√ç CON TODOS:
                Lista exacta de registros para CDmon
                    Aqu√≠ tienes todo exactamente como debe quedar:
                    üîµ CNAME 1 ‚Äî Link branding
                        Host	url9354
                        Tipo	        CNAME
                        Destino	        sendgrid.net
                    üîµ CNAME 2 ‚Äî Link branding secundario
                    Host:               56270334
                    Tipo:               CNAME
                    Destino (Value):    sendgrid.net

                    üîµ CNAME 3 ‚Äî Domain authentication (SendGrid root)
                    Host:               em1037
                    Tipo:               CNAME
                    Destino (Value):    u56270334.wl085.sendgrid.net

                    üîµ CNAME 4 ‚Äî DKIM 1
                    Host:               s1._domainkey
                    Tipo:               CNAME
                    Destino (Value):    s1.domainkey.u56270334.wl085.sendgrid.net

                    üîµ CNAME 5 ‚Äî DKIM 2
                    Host:               s2._domainkey
                    Tipo:               CNAME
                    Destino (Value):    s2.domainkey.u56270334.wl085.sendgrid.net

                    üîµ TXT ‚Äî DMARC
                    Host:               _dmarc
                    Tipo:               TXT
                    Valor:              v=DMARC1; p=none;
                                        (Es opcional, pero SendGrid lo recomienda. Puedes cambiar luego p=none por 
                                        quarantine o reject si quieres endurecer seguridad.)
***
EJEMPLO
            SendGrid te dar√° algo as√≠ (ejemplo):
                Tipo	Host	        Valor
                CNAME	em1234	        u123456.wl.sendgrid.net
                CNAME	s1._domainkey	s1.domainkey.u123456.wl.sendgrid.net
                CNAME	s2._domainkey	s2.domainkey.u123456.wl.sendgrid.net
            üìå Los valores exactos los da SendGrid en tu cuenta. NO uses estos.

            ‚ö†Ô∏è Muy importante al a√±adirlos en CDmon
            En CDmon:
            üëâ En "Nombre / Host / Alias"
            Debes poner solo lo que va antes del dominio:
            Ejemplo real de c√≥mo se introduce:
                Campo           Lo que pones
                Nombre / Host	em1234
                Tipo	        CNAME
                Destino	        u123456.wl.sendgrid.net
***

        4Ô∏è‚É£ Validar en SendGrid
            Despu√©s de guardar los registros en CDmon:
            Espera entre 5 y 20 minutos
            Vuelve a SendGrid ‚Üí Authenticate Domain ‚Üí "Verify"
            Si todo est√° correcto:
                ‚úî Authenticated
                ‚úî Los emails dejan de mostrar ‚ÄúNO VERIFICADO‚Äù
                ‚úî SPF + DKIM funcionando
                ‚úî Mejor entrega en destinatarios
        Resultado esperado
        Cuando todo est√© bien ver√°s:
        DKIM ‚Üí VALID ‚úî
        SPF ‚Üí VALID ‚úî (SendGrid a√±ade su SPF autom√°ticamente)
        Domain Authentication ‚Üí VALID ‚úî
        Link Branding ‚Üí VALID ‚úî
        Y tus correos dejar√°n de aparecer como NO VERIFICADO.

üí° Resumen:
    Single Sender Verification = env√≠os permitidos desde esa direcci√≥n, √∫til para pruebas.
    Domain Authentication = hace que tu dominio se vea verificado en todos los clientes de correo.
    Solo con domain authentication desaparece ‚ÄúNO VERIFICADO‚Äù de Gmail, Outlook, etc.




*********************
PENDING MIRAR !!! 
En express
    npm install express-validator (para velidaci√≥n de rutas)

express-validator es un paquete para Node.js que proporciona middlewares para validar y sanear datos de entrada en aplicaciones Express.js, permitiendo verificar que la informaci√≥n recibida en las peticiones (como el cuerpo, par√°metros o query strings) cumple ciertos criterios y transformarla para mejorar la seguridad. Se integra con la biblioteca validator.js y usa una "cadena" de validaciones para definir reglas para cada campo de datos. 
¬øC√≥mo funciona?
1. Validaci√≥n: express-validator permite definir reglas para cada campo que se espera en una petici√≥n. Por ejemplo, puedes especificar que un campo de email debe tener un formato de correo electr√≥nico v√°lido, o que un campo de contrase√±a debe tener una longitud m√≠nima. 
2. Saneamiento: Tambi√©n incluye funciones para "sanear" los datos, lo cual ayuda a prevenir ataques de seguridad. Esto puede incluir la limpieza de espacios en blanco o la conversi√≥n de tipos de datos. 
3. Middleware: Se integra como middleware en Express.js, lo que significa que se ejecuta antes de que la l√≥gica principal de tu ruta o controlador sea llamada. 
4. Resultados de la validaci√≥n: Si las validaciones fallan, express-validator devuelve un objeto con los errores, permitiendo enviarlos de vuelta al cliente o manejar la respuesta adecuadamente. 
Usos comunes
Validaci√≥n de formularios: Asegurar que los datos ingresados en formularios web son correctos antes de procesarlos en el backend. 
APIs: Verificar que los datos enviados a tu API cumplen los requisitos definidos, como la estructura de un JSON. 
Seguridad: Prevenir vulnerabilidades como la inyecci√≥n de c√≥digo al sanear los datos de entrada. 
Ejemplo r√°pido
JavaScript

const express = require('express');
const { body, validationResult } = require('express-validator'); // Importa body y validationResult

const app = express();

app.post('/registro', [
  // Reglas de validaci√≥n para los campos email y contrase√±a
  body('email').isEmail().withMessage('Por favor, introduce un email v√°lido'),
  body('password').isLength({ min: 5 }).withMessage('La contrase√±a debe tener al menos 5 caracteres'),
], (req, res) => {
  const errors = validationResult(req); // Captura los errores de validaci√≥n

  if (!errors.isEmpty()) {
    // Si hay errores, los devuelve al cliente
    return res.status(400).json({ errors: errors.array() });
  }

  // Si todo est√° bien, procede con la l√≥gica del registro
  // ...
});

app.listen(3000, () => console.log('Servidor en el puerto 3000'));
En este ejemplo, se usa body() para validar campos en el cuerpo de la petici√≥n, se comprueba que el email sea v√°lido y la password tenga al menos 5 caracteres. Si no, se devuelven los errores. 
*********************
