EJEMPLO DE USO SIN GUARDAR EN LOCALSTORAGE, PERO RECUPERANDO EL TOKEN DESDE Backend APROVECHANDO LO HECHO HASTA Ahora

implementación completa desde cero de un sistema de autenticación seguro usando React + fetch (sin axios) y Express (Node.js), 
con:

✅ Access token en memoria.

✅ Refresh token en cookie HttpOnly.

✅ Renovación automática del token cuando expira.

✅ Uso de fetch para todas las peticiones.

🛠️ BACKEND: Express + JWT + Cookies
🧱 Requisitos

Instala las dependencias:

npm install express jsonwebtoken cookie-parser cors dotenv

✅ server.js
const express = require('express');
const jwt = require('jsonwebtoken');
const cookieParser = require('cookie-parser');
const cors = require('cors');

const app = express();
app.use(express.json());
app.use(cookieParser());

app.use(cors({
  origin: 'http://localhost:3000',
  credentials: true // Permitir envío de cookies
}));

const USERS = [{ id: 1, username: 'admin', password: '1234' }];

const ACCESS_SECRET = 'ACCESS_SECRET';
const REFRESH_SECRET = 'REFRESH_SECRET';

const createAccessToken = (user) => jwt.sign({ id: user.id }, ACCESS_SECRET, { expiresIn: '15m' });
const createRefreshToken = (user) => jwt.sign({ id: user.id }, REFRESH_SECRET, { expiresIn: '7d' });

app.post('/login', (req, res) => {
  const { username, password } = req.body;
  const user = USERS.find(u => u.username === username && u.password === password);

  if (!user) return res.status(401).json({ message: 'Invalid credentials' });

  const accessToken = createAccessToken(user);
  const refreshToken = createRefreshToken(user);

  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: false, // cambia a true si usas HTTPS
    sameSite: 'Strict',
    path: '/refresh',
    maxAge: 7 * 24 * 60 * 60 * 1000 // 7 días
  });

  res.json({ accessToken });
});

app.post('/refresh', (req, res) => {
  const token = req.cookies.refreshToken;
  if (!token) return res.sendStatus(401);

  try {
    const payload = jwt.verify(token, REFRESH_SECRET);
    const accessToken = createAccessToken({ id: payload.id });
    res.json({ accessToken });
  } catch (err) {
    res.sendStatus(403);
  }
});

app.get('/protected', (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) return res.sendStatus(401);

  const token = authHeader.split(' ')[1];
  try {
    const payload = jwt.verify(token, ACCESS_SECRET);
    res.json({ message: 'Access granted', userId: payload.id });
  } catch {
    res.sendStatus(403);
  }
});

app.listen(4000, () => console.log('✅ Auth server running on http://localhost:4000'));

🌐 FRONTEND: React + fetch
🧱 Requisitos

Crea un proyecto React (si no lo tienes aún):

npx create-react-app auth-frontend
cd auth-frontend

✅ src/App.js
import React, { useState, useEffect } from 'react';

function App() {
  const [accessToken, setAccessToken] = useState(null);
  const [protectedData, setProtectedData] = useState(null);

  // Login: obtiene accessToken y deja refreshToken en cookie
  const login = async () => {
    try {
      const res = await fetch('http://localhost:4000/login', {
        method: 'POST',
        credentials: 'include', // envía cookies
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          username: 'admin',
          password: '1234'
        })
      });

      if (!res.ok) throw new Error('Login failed');
      const data = await res.json();
      setAccessToken(data.accessToken);
    } catch (err) {
      alert('Login error');
    }
  };

  // Accede a ruta protegida
  const getProtected = async () => {
    try {
      const res = await fetch('http://localhost:4000/protected', {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${accessToken}`
        }
      });

      if (res.status === 401 || res.status === 403) {
        await refreshToken(); // si expira, intenta renovar
        return;
      }

      const data = await res.json();
      setProtectedData(data.message);
    } catch (err) {
      alert('Error al acceder');
    }
  };

  // Refresca access token usando el refresh token en cookie
  const refreshToken = async () => {
    try {
      const res = await fetch('http://localhost:4000/refresh', {
        method: 'POST',
        credentials: 'include' // importante: envía cookie HttpOnly
      });

      if (!res.ok) throw new Error('Refresh failed');
      const data = await res.json();
      setAccessToken(data.accessToken);
    } catch (err) {
      alert('Sesión expirada, vuelve a iniciar sesión');
      setAccessToken(null);
    }
  };

  // Intenta refrescar token al cargar la app
  useEffect(() => {
    refreshToken();
  }, []);

  return (
    <div>
      <h1>🔐 Auth con Fetch</h1>
      <button onClick={login}>Iniciar sesión</button>
      <button onClick={getProtected}>Acceder a ruta protegida</button>
      <p>{protectedData}</p>
    </div>
  );
}

export default App;

✅ Resultado
Elemento	Ubicación	Seguridad
Access Token	Memoria (useState)	No persiste, menos vulnerable a XSS
Refresh Token	Cookie HttpOnly	Inaccesible desde JavaScript
🧪 Pruebas

Inicia el backend (node server.js).

Inicia React (npm start en la carpeta del frontend).

Haz clic en Iniciar sesión.

Haz clic en Acceder a ruta protegida.

Si pasa el tiempo (15 min), se refresca automáticamente el token usando la cookie.


