PARTIENDO DE 14InstalacionServidorTEST1.txt HASTA LA INSTALACION DE DOCKER ENGINE
SEGUIMOS ...

separar frontend y backend en contenedores es lo mÃ¡s limpio, incluso en Windows Server 2022.
Vamos a hacerlo bien y claro, usando Vite + Express, 2 contenedores, y Nginx delante.

ğŸ§­ FLUJO COMPLETO DESDE 0 (con Docker Compose y Nginx)
0ï¸âƒ£ Idea clave

Desarrollo: React + Vite y Express ESM sin Docker.

ProducciÃ³n: imÃ¡genes Docker construidas por GitHub Actions, servidor solo ejecuta contenedores.

1ï¸âƒ£ Estructura del proyecto en tu PC (desarrollo)
myapp/
â”œâ”€ frontend/          â† React + Vite
â”‚  â”œâ”€ src/            â† cÃ³digo React
â”‚  â”œâ”€ public/         â† archivos estÃ¡ticos
â”‚  â”œâ”€ package.json
â”‚  â”œâ”€ vite.config.js
â”‚  â”œâ”€ Dockerfile      â† PRODUCCIÃ“N: NO se usa en desarrollo
â”‚  â””â”€ nginx.conf      â† PRODUCCIÃ“N
â”œâ”€ backend/           â† Express ESM
â”‚  â”œâ”€ server.js
â”‚  â”œâ”€ package.json
â”‚  â””â”€ Dockerfile      â† PRODUCCIÃ“N: NO se usa en desarrollo
â”œâ”€ docker-compose.yml  â† PRODUCCIÃ“N en servidor
â””â”€ .gitignore


.gitignore recomendado:

node_modules
frontend/dist


ğŸ”‘ Los Dockerfiles existen en el repo pero no se ejecutan en tu PC.

2ï¸âƒ£ Desarrollo en tu PC

Frontend

cd frontend
npm install
npm run dev


React + Vite corre en http://localhost:5173

IteraciÃ³n rÃ¡pida sin Docker ni Nginx

Backend

cd backend
npm install
node server.js


Express ESM corre en http://localhost:3000

ğŸ”‘ En desarrollo NO se usan Dockerfiles ni Docker.

3ï¸âƒ£ Preparar Dockerfiles (producciÃ³n)

Frontend Dockerfile (frontend/Dockerfile)

# Build
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Runtime
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80


Backend Dockerfile (backend/Dockerfile)

FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install --production
COPY . .
EXPOSE 3000
CMD ["node", "server.js"]


Nginx config (frontend/nginx.conf)

server {
    listen 80;

    server_name _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri /index.html;
    }

    location /api/ {
        proxy_pass http://backend:3000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}


ğŸ”‘ /api/ se reenvÃ­a al contenedor backend.

4ï¸âƒ£ Subir el cÃ³digo a GitHub
git init
git add .
git commit -m "Initial commit"
git push


Ahora el repo contiene:

CÃ³digo de frontend y backend

Dockerfiles (producciÃ³n)

nginx.conf

5ï¸âƒ£ GitHub Actions â€” Build de producciÃ³n

Clona el repo

Instala Node

Ejecuta npm run build en frontend â†’ genera dist

Construye imÃ¡genes Docker:

frontend â†’ Nginx + dist

backend â†’ Express

Publica imÃ¡genes en un registry (Docker Hub o GHCR)

âœ… AquÃ­ sÃ­ se usan los Dockerfiles
âŒ No se ejecutan en tu PC ni en el servidor

6ï¸âƒ£ Preparar el servidor (Windows Server 2022)

Instalar Docker Engine + Docker Compose

NO instalar Node, npm ni Vite

NO ejecutar Dockerfiles

Crear directorio para ejecutar Compose:

C:\projects\myapp
â”œâ”€ docker-compose.yml

7ï¸âƒ£ Docker Compose para producciÃ³n (docker-compose.yml)
version: "3.9"

services:
  frontend:
    image: ghcr.io/usuario/frontend:latest
    container_name: frontend
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - myapp-network

  backend:
    image: ghcr.io/usuario/backend:latest
    container_name: backend
    environment:
      - SUPABASE_URL=${SUPABASE_URL}
      - SUPABASE_KEY=${SUPABASE_KEY}
    networks:
      - myapp-network

networks:
  myapp-network:
    driver: bridge


ğŸ”‘ Variables de Supabase se pueden definir en un .env y se inyectan al backend.

8ï¸âƒ£ Ejecutar Docker en el servidor
cd C:\projects\myapp

# Descargar imÃ¡genes (si no estÃ¡n locales)
docker pull ghcr.io/usuario/frontend
docker pull ghcr.io/usuario/backend

# Levantar contenedores
docker compose up -d


âœ… El servidor solo ejecuta contenedores, no compila nada, no necesita Node ni Vite ni Dockerfiles.

9ï¸âƒ£ Estructura final en el servidor
C:\projects\myapp
â”œâ”€ frontend/
â”‚  â”œâ”€ Dockerfile       â† PRODUCCIÃ“N: usado solo por GitHub Actions
â”‚  â””â”€ nginx.conf
â”œâ”€ backend/
â”‚  â”œâ”€ server.js
â”‚  â”œâ”€ package.json
â”‚  â””â”€ Dockerfile       â† PRODUCCIÃ“N: usado solo por GitHub Actions
â””â”€ docker-compose.yml


dist NO existe en el servidor.
Frontend corre React build servido por Nginx dentro del contenedor.
Backend corre Express dentro del contenedor.

9ï¸âƒ£ Resumen visual del flujo
Entorno	QuÃ© pasa
PC (dev)	React + Vite (npm run dev), Node backend (node server.js) âœ…
GitHub Actions	Construye dist, crea imÃ¡genes Docker usando Dockerfiles âœ…
Servidor	Docker Compose levanta contenedores âœ…, no necesita Node/Vite âŒ

âœ… Frase final clave

En desarrollo no se usan Dockerfiles ni Docker.
Dockerfiles existen en el repo para GitHub Actions, y el servidor solo ejecuta contenedores desde PowerShell.

Si quieres, puedo hacer ahora una versiÃ³n completa lista para producciÃ³n con .env.example y 
HTTPS con Let's Encrypt, para que solo con un docker compose up -d tengas todo seguro y funcionando.

Â¿Quieres que haga eso tambiÃ©n? PENDING !!!!
