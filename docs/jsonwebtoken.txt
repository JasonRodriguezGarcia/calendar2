RESUMEN
1¬∫ Login usuario_id+contrase√±a -->https backend textoplano
2¬∫ Backend compara id+password con base de datos
3¬∫ Si todo ok recibe token a guardar en localstorage
Cada llamada a backend tengra una l√≠nea m√°s con headers:
    fetch('http://localhost:3001/api/protegido', {
      headers: { Authorization: `Bearer ${token}` },
    })
Cada ruta en backend tendr√° adem√°s un middleware que tambi√©n mirar√° la cookie
    router.get('/usuario', authenticateToken, async(req, res) => {
        ...
    })
    ...

    const authenticateToken (req, res, next) {
        // lee el token desde la cookie
        const token = req.cookies.token;
        ...
    }

ENCRIPTACI√ìN CON JSONWEBTOKEN
*****************************

en backend instalar jsonwebtoken
en frontend instalar jwt-decode para que el App.jsx recupere los datos del usuario al pulsar F5 desencriptando
    el token y sacando los datos oportunos para llamar a /usuario y establecer usuario en la aplicaci√≥n
*****************************
MIRAR TAMBI√âN EN 
    https://github.com/chekulhan/Desarrollo-Web/blob/4a2c5a70a1a60d414aacde2a7746a1c19ed9e400/UF1844-Entorno-Servidor/express/09-autenticacion.jwt.md

MEC√ÅNICA DE USO
‚úÖ ¬øQu√© deber√≠as hacer?
1. Enviar la contrase√±a en texto plano, PERO SOLO POR HTTPS !!!!
                                        ------------------------
{
  "usuario_id": "juan123",
  "password": "miContrase√±aSegura123"
}


Se env√≠a en el body de un POST al backend para iniciar sesi√≥n.

üîê HTTPS se encarga de cifrar todo en tr√°nsito.

As√≠, nadie en medio (ni hackers, ni ISP, ni redes p√∫blicas) puede ver el contenido.

El backend recibir√° la contrase√±a de forma segura para hacer el hash y compararla.

‚ùå ¬øPor qu√© no deber√≠as hashear la contrase√±a en frontend?
1. bcrypt es lento y no est√° dise√±ado para ejecutarse en el navegador

Puede bloquear la UI y afectar la experiencia de usuario.

2. El hash se puede interceptar igual que una contrase√±a

Si env√≠as el hash al backend y lo usas como "clave", ya no es un hash seguro: ahora es un secreto reutilizable, igual de valioso para un atacante.

3. Pierdes control del proceso de autenticaci√≥n

El servidor deber√≠a tener control total sobre la l√≥gica de validaci√≥n.

üîí Entonces, ¬øcu√°l es el flujo de login seguro?
üì≤ Frontend (React)
// Ejemplo usando fetch
const response = await fetch('/api/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    usuario_id: 'juan123',
    password: 'miContrase√±aSegura123'
  })
});

üñ•Ô∏è Backend (Node.js + Express + bcrypt)
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

app.post('/api/login', async (req, res) => {
  const { usuario_id, password } = req.body;

  const user = await User.findOne({ usuario_id });

  if (!user) return res.status(401).json({ error: 'Usuario no encontrado' });

  const match = await bcrypt.compare(password, user.password_hash);

  if (!match) return res.status(401).json({ error: 'Contrase√±a incorrecta' });

  const token = jwt.sign(
    { id: user._id, usuario_id: user.usuario_id },
    process.env.JWT_SECRET,
    { expiresIn: '15m' }
  );

  res.json({ token });
});

‚úÖ ¬øC√≥mo proteger esa primera llamada?

Siempre usar HTTPS

No enviar datos en la URL

POST con Content-Type: application/json

Validar todo en el backend

(Opcional) Rate limit para evitar fuerza bruta

(Opcional) A√±adir reCAPTCHA u otro sistema si recibes mucho tr√°fico

üß† Resumen
Tema	Recomendaci√≥n
¬øEncriptar contrase√±a en frontend?	‚ùå No ‚Äì Usa HTTPS y env√≠ala tal cual en body
¬øUsar bcrypt en frontend?	‚ùå No ‚Äì Solo en el backend
¬øEnv√≠o seguro?	‚úÖ S√≠, usando HTTPS y m√©todo POST
¬øValidaci√≥n?	‚úÖ Se hace toda en backend con bcrypt
‚úÖ TL;DR

No es necesario ni recomendable encriptar la contrase√±a en frontend.
Usa HTTPS, manda usuario_id y password en el body de un POST, y deja que el backend valide y genere el token JWT.

******************
EJEMPLO FUNCIONAL DE LOGIN
******************

vamos a armar un ejemplo funcional completo y seguro de autenticaci√≥n con:

Frontend: React

Backend: Express.js + bcrypt + JWT

üß± Estructura general del ejemplo

Usuario ingresa su usuario_id y password en React

Se env√≠a un POST al backend /api/login

Backend valida con bcrypt y genera un JWT

El token se guarda en localStorage

El token se env√≠a en cada llamada protegida (Authorization: Bearer <token>)

El backend protege rutas validando el token con jsonwebtoken

üñ•Ô∏è BACKEND (Node.js + Express)
üì¶ Instalar dependencias
npm install express bcrypt jsonwebtoken cors dotenv

üìÑ .env
JWT_SECRET=mi_super_secreto

üìÅ server.js
const express = require('express');
const cors = require('cors');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
require('dotenv').config();

const app = express();
app.use(cors());
app.use(express.json());

// Mock de base de datos en memoria
const users = [
  {
    id: 1,
    usuario_id: 'juan123',
    password_hash: bcrypt.hashSync('miContrase√±aSegura123', 10),
  }
];

// üîê LOGIN
app.post('/api/login', async (req, res) => {
  const { usuario_id, password } = req.body;

  const user = users.find(u => u.usuario_id === usuario_id);
  if (!user) return res.status(401).json({ error: 'Usuario no encontrado' });

  const isValid = await bcrypt.compare(password, user.password_hash);
  if (!isValid) return res.status(401).json({ error: 'Contrase√±a incorrecta' });

  const token = jwt.sign(
    { id: user.id, usuario_id: user.usuario_id },  //bastar√≠a con un campo id
    process.env.JWT_SECRET,
    { expiresIn: '15m' }
    // { expiresIn: '1h', algorithm: 'HS256' }, // tambi√©n valdr√≠a
  );

  res.json({ token });
});

// üîí RUTA PROTEGIDA
app.get('/api/protegido', verifyToken, (req, res) => {
  res.json({ mensaje: 'Acceso autorizado', usuario: req.user });
});

// üß™ Middleware para verificar el token
function verifyToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) return res.status(401).json({ error: 'Token faltante' });

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: 'Token inv√°lido o expirado' });
    req.user = user;
    next();
  });
}

app.listen(3001, () => console.log('Servidor escuchando en http://localhost:3001'));

üåê FRONTEND (React)

Asumimos que usas create-react-app o similar.

üìÑ Login.jsx
import { useState } from 'react';

export default function Login() {
  const [usuario_id, setUsuarioId] = useState('');
  const [password, setPassword] = useState('');

  const handleLogin = async () => {
    const res = await fetch('http://localhost:3001/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ usuario_id, password }),
    });

    const data = await res.json();

    if (res.ok) {
      localStorage.setItem('token', data.token);
      alert('Login exitoso');
    } else {
      alert('Error: ' + data.error);
    }
  };

  return (
    <div>
      <h2>Login</h2>
      <input placeholder="Usuario ID" value={usuario_id} onChange={e => setUsuarioId(e.target.value)} />
      <input placeholder="Contrase√±a" type="password" value={password} onChange={e => setPassword(e.target.value)} />
      <button onClick={handleLogin}>Iniciar sesi√≥n</button>
    </div>
  );
}

üìÑ RutaProtegida.jsx
import { useEffect, useState } from 'react';

export default function RutaProtegida() {
  const [mensaje, setMensaje] = useState('');

  useEffect(() => {
    const token = localStorage.getItem('token');

    fetch('http://localhost:3001/api/protegido', {
      headers: { Authorization: `Bearer ${token}` },
    })
      .then(res => res.json())
      .then(data => {
        if (data.error) {
          setMensaje(`Error: ${data.error}`);
        } else {
          setMensaje(data.mensaje + ' (Usuario: ' + data.usuario.usuario_id + ')');
        }
      });
  }, []);

  return (
    <div>
      <h2>Ruta Protegida</h2>
      <p>{mensaje}</p>
    </div>
  );
}

‚úÖ Resultado

Usuario inicia sesi√≥n ‚Üí token se guarda en localStorage

Rutas protegidas validan el token antes de permitir acceso

Todo el flujo es seguro si usas HTTPS

üîê Seguridad adicional (recomendado para producci√≥n)

Usa cookies seguras (httpOnly) si prefieres mayor protecci√≥n contra XSS

Implementa expiraci√≥n de sesi√≥n y refresh tokens

Aplica CORS con origen espec√≠fico

A√±ade protecci√≥n contra XSS y CSRF



*******************
EJEMPLO DE UN PUT
*******************


Actualizar datos de un usuario con PUT o PATCH es una parte fundamental de cualquier sistema. Vamos a ver:

‚úÖ Flujo completo para actualizar un usuario

Supongamos que el usuario ya inici√≥ sesi√≥n y tienes un token JWT guardado en localStorage.

üîÑ 1. Frontend (React)
Supongamos que quieres permitir al usuario cambiar su nombre y email.
üìÑ Componente de edici√≥n (EditarUsuario.jsx)
import { useState, useEffect } from 'react';

export default function EditarUsuario() {
  const [nombre, setNombre] = useState('');
  const [email, setEmail] = useState('');

  const token = localStorage.getItem('token');

  // Opcional: cargar datos actuales del usuario
  useEffect(() => {
    fetch('http://localhost:3001/api/usuario/me', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    })
      .then(res => res.json())
      .then(data => {
        setNombre(data.nombre);
        setEmail(data.email);
      });
  }, []);

  const handleUpdate = async () => {
    const res = await fetch('http://localhost:3001/api/usuario', {
      method: 'PUT', // o PATCH si solo cambias una parte
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`
      },
      body: JSON.stringify({
        nombre,
        email
      })
    });

    const data = await res.json();
    if (res.ok) {
      alert('Usuario actualizado correctamente');
    } else {
      alert('Error: ' + data.error);
    }
  };

  return (
    <div>
      <h2>Editar Usuario</h2>
      <input value={nombre} onChange={e => setNombre(e.target.value)} placeholder="Nombre" />
      <input value={email} onChange={e => setEmail(e.target.value)} placeholder="Email" />
      <button onClick={handleUpdate}>Guardar cambios</button>
    </div>
  );
}

üñ•Ô∏è 2. Backend (Express + JWT)
üìÑ Ruta PUT /api/usuario
Requisitos:

Middleware para verificar el token (verifyToken)

Obtener el id del usuario desde el JWT

Validar y actualizar los campos

// ‚úÖ Middleware para proteger rutas
function verifyToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader?.split(' ')[1];

  if (!token) return res.status(401).json({ error: 'Token faltante' });

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: 'Token inv√°lido' });
    req.user = user; // contiene el payload del token
    next();
  });
}

üìÑ Ruta de actualizaci√≥n
app.put('/api/usuario', verifyToken, async (req, res) => {
  const userId = req.user.id;
  const { nombre, email } = req.body;

  // Aqu√≠ simulas una base de datos en memoria (debes adaptar a tu DB real)
  const user = users.find(u => u.id === userId);
  if (!user) return res.status(404).json({ error: 'Usuario no encontrado' });

  // Validaciones opcionales aqu√≠
  if (nombre) user.nombre = nombre;
  if (email) user.email = email;

  res.json({ mensaje: 'Usuario actualizado', user });
});

üõ†Ô∏è Notas t√©cnicas
Aspecto	Recomendaci√≥n
M√©todo HTTP	PUT si reemplazas todos los campos, PATCH si solo algunos
ID del usuario	Obtenido desde el JWT (req.user.id)
Seguridad	Siempre usar Authorization: Bearer <token>
Validaciones	Sanitiza y valida en backend los datos recibidos
Base de datos	Aqu√≠ usamos un array users[], pero deber√≠as usar MongoDB, PostgreSQL, etc.
üß† Alternativas √∫tiles
Si quieres permitir editar otro usuario (no el actual):

La ruta puede ser: PUT /api/usuarios/:id

Aseg√∫rate de verificar que el usuario tenga permisos para editar a otro.

‚úÖ TL;DR

En React: Env√≠as un PUT a /api/usuario con token en header y los campos a actualizar en el body.

En backend: Verificas el token, obtienes el id, validas datos y actualizas el usuario.

****************
****************
****************

Pasos realizados

En backend
- crear una variable JWT_SECRET con una cadena secreta
- crear directorio en backend /middleware
- dentro crear login.js con la funci√≥n authenticateToken 
- en /models/usuariosModel.js a√±adiremos la generaci√≥n del jwt en la funci√≥n postLogin
