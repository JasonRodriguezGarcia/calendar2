***************************************
Limitar Intentos de Inicio de Sesi√≥n Login (login limiting)
***************************************
Una de las formas m√°s eficaces de protegerte contra los ataques de fuerza bruta es limitar la cantidad de intentos de 
inicio de sesi√≥n fallidos que un usuario puede hacer en un corto per√≠odo de tiempo. Esto reduce el riesgo de que un atacante 
pueda probar muchas combinaciones de contrase√±as r√°pidamente.

Puedes usar un middleware en Express.js como express-rate-limit para implementar esto.
Instalar express-rate-limit:
    npm install express-rate-limit

Ejemplo de configuraci√≥n para proteger las rutas de login:

import rateLimit from 'express-rate-limit';

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // reseteo del bloque a los 15 minutos
  max: 5, // Limitar a 5 intentos
  message: "Demasiados intentos de inicio de sesi√≥n. Por favor, intente de nuevo en 15 minutos.",
  √≥ tambi√©n message: {message: "Demasiados intentos de inicio de sesi√≥n. Por favor, intente de nuevo en 15 minutos."},
  standardHeaders: true,
  legacyHeaders: false,
});

// Usar el rate limiter solo en la ruta de login
router.post('/login', loginLimiter, async (req, res) => {
  // Tu l√≥gica de autenticaci√≥n aqu√≠
});

En frontend
    const response = await fetch(`${VITE_BACKEND_URL_RENDER}/api/v1/erroak/login`,
        {
            method: 'POST',
            credentials: 'include', // IMPORTANTE: esto permite usar la cookie
            headers: {'Content-type': 'application/json; charset=UTF-8'},
            body: JSON.stringify(user)
        }
    )
    const data = await response.json()
    if (response.status === 429) {
        // const data = await response.json();
        setErrorMessage(data.message || 'Demasiados intentos. Intente de nuevo m√°s tarde.')
        return
    }
    console.log("Respuesta backend: ", data)
    if (data.result === "No encontrado") {
...............
    }

Usando el siguiente codigo
    keyGenerator: (req, res) => {
    const user = req.body?.usuario || 'anon';
    return `${req.ip}-${user}`;
    },
Esto evita que un atacante desde una sola IP pruebe usuarios distintos ilimitadamente.

***************************************
Limitar el n√∫mero de solicitudes API (rate limiting)
***************************************
Limitar el N√∫mero de Solicitudes (Rate Limiting)

Al igual que con los ataques de fuerza bruta, puedes aplicar rate limiting en todas las rutas o en rutas espec√≠ficas de 
tu API. Esto no solo ayuda a prevenir ataques de fuerza bruta, sino que tambi√©n limita el impacto de un ataque DDoS al controlar el volumen de solicitudes por IP.

Ejemplo (en express claro):
    import rateLimit from 'express-rate-limit'; // PONER ANTES DE LOS ROUTER'S

app.use('/api/', apiLimiter); // Usar rate limiter en todas las rutas de la API

se puede combinar con authenticateToken si queremos meterlo en usuarios router tambi√©n ojo el orden, pero es mejor lo de arriba
router.post('/login', apiLimiter, authenticateToken, ...); // Usar rate limiter en una api en concreto, pero mejor en index.js

En middleware importado
const apiLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // reseteo del bloqueo cada 1 minuto
  max: 100, // Limitar a 100 solicitudes por IP por minuto
  message: "Demasiadas solicitudes. Por favor, intente nuevamente m√°s tarde.",
  standardHeaders: true,
  legacyHeaders: false,
});

A√±adir middleware en router usuarios.js
// L√≠mite espec√≠fico para registro .post('/usuario', ...)
export const registerLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hora
  max: 5, // m√°ximo 5 registros por IP en una hora
  message: {
    success: false,
    message: "Demasiadas solicitudes de registro. Intente m√°s tarde.",
  },
  standardHeaders: true,
  legacyHeaders: false,
})

*********************************
PROTECCI√ìN CONTRA ATAQUES CSRF
*********************************
En este caso porque tenemos frontend y backend en distintos dominios.
Tenemos configurado
    SameSite='none' y no Lax o Strict

Explicacion ataque CSRF
Un ataque CSRF (Cross-Site Request Forgery) ‚Äîen espa√±ol, falsificaci√≥n de petici√≥n en sitios cruzados‚Äî es un tipo de vulnerabilidad que afecta a aplicaciones web del lado del backend, y que permite a un atacante hacer que un usuario autenticado ejecute acciones no deseadas en un sitio web en el que est√° logueado.

üß† Ejemplo conceptual

Imagina que est√°s logueado en tu banco (banco.com) y, mientras tanto, visitas un sitio malicioso (malicio.us).
Este sitio contiene un formulario oculto que env√≠a una petici√≥n POST a:

https://banco.com/transferir


con los datos:

{
  "cuenta_destino": "12345678",
  "monto": 1000
}


Cuando tu navegador carga la p√°gina maliciosa, autom√°ticamente env√≠a esa petici√≥n con tus cookies de sesi√≥n, porque 
sigues autenticado en banco.com.
El backend del banco recibe la solicitud, ve que est√° autenticada (por las cookies), y realiza la transferencia sin 
sospechar que no fue el usuario quien la inici√≥.

‚öôÔ∏è C√≥mo funciona t√©cnicamente

El usuario inicia sesi√≥n en un sitio leg√≠timo ‚Üí obtiene una cookie de sesi√≥n.
El atacante prepara una p√°gina maliciosa que env√≠a peticiones HTTP al mismo dominio (por ejemplo, usando un formulario 
o una petici√≥n fetch).
El navegador del usuario env√≠a la cookie de sesi√≥n autom√°ticamente, haciendo que el backend piense que la solicitud es leg√≠tima.
El servidor ejecuta la acci√≥n no deseada (p. ej., cambio de contrase√±a, transferencia, eliminaci√≥n de cuenta‚Ä¶).
üõ°Ô∏è C√≥mo se previene en el backend

Tokens CSRF (anti-CSRF tokens)
El backend genera un token √∫nico y lo env√≠a al frontend (por ejemplo, en un campo oculto del formulario o en el 
encabezado de la respuesta).
El frontend debe incluir ese token en cada solicitud que modifique datos (POST, PUT, DELETE...).
Si el token no coincide, el backend rechaza la solicitud.

Cabeceras personalizadas (en APIs)
Las peticiones leg√≠timas usan cabeceras especiales (como X-CSRF-Token o X-Requested-With).
Navegadores no env√≠an esas cabeceras autom√°ticamente, as√≠ que los ataques CSRF no pueden replicarlas.

SameSite cookies
Configurar la cookie de sesi√≥n con SameSite=Lax o Strict evita que se env√≠e autom√°ticamente desde otros dominios.

Validar origen y referer
El servidor puede comprobar las cabeceras Origin o Referer para asegurarse de que la solicitud proviene del dominio esperado.

üìã En resumen
Elemento	Descripci√≥n
Tipo de ataque	Cross-Site Request Forgery
Afecta a	Backends que conf√≠an solo en cookies/sesiones
Riesgo principal	Ejecuci√≥n de acciones sin consentimiento del usuario
Prevenci√≥n	Tokens CSRF, SameSite cookies, validaci√≥n de origen


EN NUESTRO CASO
Ya que usamos cookies HttpOnly cross-domain, la opci√≥n CSRF token (Double Submit Cookie) es la m√°s segura.

Comb√≠nalo con:
Rate limiting (ya lo tienes)
Verificaci√≥n de origin/referer como capa extra
SameSite cookies en endpoints internos si es posible

Opci√≥n: CSRF Tokens (Double Submit Cookie)
Backend genera un token CSRF diferente del JWT.
Se env√≠a al frontend (puede ser en una cookie normal o en la respuesta JSON).
Frontend lo env√≠a en cada request sensible, en un header como X-CSRF-Token.
Backend valida que el token coincida.

Ejemplo con Express y csurf:

import csurf from 'csurf';
import cookieParser from 'cookie-parser';

app.use(cookieParser());

const csrfProtection = csurf({
  cookie: {
    httpOnly: false, // accesible desde frontend
    sameSite: 'strict'
  }
});

app.get('/csrf-token', csrfProtection, (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

app.post('/update-profile', csrfProtection, (req, res) => {
  res.send('Perfil actualizado');
});


El frontend obtiene el token de /csrf-token (recomendado ponderlo en app.jsx)
  useEffect(() => {
    fetch('https://backend.com/csrf-token', {
      credentials: 'include'
    })
      .then(res => res.json())
      .then(data => {
        console.log('CSRF Token:', data.csrfToken);
        setCsrfToken(data.csrfToken);
      })
      .catch(err => console.error('Error obteniendo CSRF:', err));
  }, []);


y lo env√≠a en un header:

fetch('https://backend.com/update-profile', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken
  },
  body: JSON.stringify({ name: 'Juan' })
});

Mas ejemplos
EJEMPLO1
***********************************
Una implementaci√≥n manual de CSRF (con crypto.randomBytes) en lugar de csurf, para que vieras claramente el flujo 
completo y c√≥mo integrarlo con JWT HttpOnly + frontend separado.

Pero si quieres una versi√≥n m√°s robusta y autom√°tica, podemos integrar csurf perfectamente.
Te explico ambos enfoques y luego te dejo el c√≥digo completo con csurf.

‚öñÔ∏è Diferencias entre csurf y una soluci√≥n manual
Enfoque	Ventajas	Desventajas
üîπ Manual (como el ejemplo anterior)	Control total, f√°cil de combinar con JWT y frontends SPA; no dependes de sesiones.	
    Tienes que implementar la validaci√≥n t√∫ mismo.
üîπ csurf middleware	Autom√°tico, probado y s√≥lido; maneja tokens, cookies y validaci√≥n.	Originalmente dise√±ado para apps 
    con sessions (Express-session); con JWT hay que adaptarlo.


üí° C√≥mo usar csurf con JWT (sin sesiones)
Por defecto, csurf guarda el token en la sesi√≥n (req.session.csrfSecret).
Pero como t√∫ usas JWT (sin sesiones), debemos configurarlo para que guarde el secreto en una cookie.

As√≠, csurf:
    Genera un token CSRF basado en ese secreto.
    Lo env√≠a al frontend.
    Valida autom√°ticamente el header X-CSRF-Token en cada request protegida.

üß© BACKEND con csurf
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import csurf from 'csurf';

dotenv.config();
const app = express();

app.use(express.json());
app.use(cookieParser());
app.use(cors({
  origin: 'https://frontend.com',
  credentials: true,
}));

// Middleware de autenticaci√≥n
function authMiddleware(req, res, next) {
  const token = req.cookies.token;
  if (!token) return res.status(401).json({ message: 'No token' });
  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET);
    next();
  } catch {
    res.status(401).json({ message: 'Token inv√°lido' });
  }
}

// Configurar csurf con cookie (sin sesiones)
const csrfProtection = csurf({
  cookie: {
    key: '_csrfSecret',  // cookie donde guarda el secreto
    httpOnly: true,      // no accesible desde JS
    sameSite: 'none',
    secure: true,
  },
});

// üîπ Endpoint para obtener el token CSRF
app.get('/csrf-token', csrfProtection, (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

// üîπ Login (genera JWT)
app.post('/login', (req, res) => {
  const { username } = req.body;
  const jwtToken = jwt.sign({ username }, process.env.JWT_SECRET, { expiresIn: '1h' });

  res.cookie('token', jwtToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'none',
    maxAge: 60 * 60 * 1000,
  });

  res.json({ success: true });
});

// üîπ Ruta protegida con JWT + CSRF
app.post('/update-profile', authMiddleware, csrfProtection, (req, res) => {
  res.json({ message: `Perfil de ${req.user.username} actualizado correctamente.` });
});

// üîπ Logout
app.post('/logout', (req, res) => {
  res.clearCookie('token', { sameSite: 'none', secure: true });
  res.clearCookie('_csrfSecret', { sameSite: 'none', secure: true });
  res.json({ success: true });
});

app.listen(4000, () => console.log('‚úÖ Backend con csurf activo'));

‚öõÔ∏è FRONTEND (React)

Tu flujo sigue igual, solo que ahora el CSRF lo pides con /csrf-token:

async function getCSRFToken() {
  const res = await fetch('https://backend.com/csrf-token', {
    credentials: 'include',
  });
  const data = await res.json();
  return data.csrfToken;
}

// Ejemplo de uso
const csrfToken = await getCSRFToken();

await fetch('https://backend.com/update-profile', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken,
  },
  body: JSON.stringify({ name: 'Nuevo nombre' }),
});

üîê Qu√© hace autom√°ticamente csurf

‚úÖ Genera un secreto por usuario y lo guarda en una cookie HttpOnly (_csrfSecret).
‚úÖ Crea un token firmado √∫nico (req.csrfToken()) que el frontend debe enviar.
‚úÖ Valida autom√°ticamente ese token en cada request protegida.
‚úÖ Si el token no coincide, lanza error 403 (EBADCSRFTOKEN).

üß© Combinaci√≥n recomendada

JWT en cookie HttpOnly ‚Üí autentica al usuario.

csurf con cookie propia ‚Üí valida intenci√≥n del usuario.

cors con credentials: true ‚Üí permite cookies cross-domain.

EJEMPLO2
**********************************************
el backend regenerar√° el token CSRF autom√°ticamente al hacer login y lo invalidar√° o renovar√° al hacer logout.
As√≠, tu frontend no necesita pedirlo manualmente ‚Äî solo lo actualiza cuando cambia el estado de autenticaci√≥n.

üß± Objetivo del flujo

Usuario entra ‚Üí si no hay sesi√≥n, no hay token CSRF.

Usuario hace login ‚Üí backend crea:

JWT en cookie HttpOnly

CSRF token (en JSON o cookie accesible)

Usuario hace peticiones autenticadas ‚Üí env√≠a X-CSRF-Token.

Usuario hace logout ‚Üí backend borra cookie JWT y genera un nuevo CSRF token ‚Äúvac√≠o‚Äù (o inv√°lido).

üß© BACKEND (Express)
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import crypto from 'crypto'; // para generar tokens CSRF simples

dotenv.config();
const app = express();

app.use(express.json());
app.use(cookieParser());
app.use(cors({
  origin: 'https://frontend.com',
  credentials: true,
}));

// Middleware de autenticaci√≥n JWT
function authMiddleware(req, res, next) {
  const token = req.cookies.token;
  if (!token) return res.status(401).json({ message: 'No token' });
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch {
    res.status(401).json({ message: 'Token inv√°lido' });
  }
}

// Generar CSRF token seguro (simple y r√°pido)
function generateCSRFToken() {
  return crypto.randomBytes(32).toString('hex');
}

// LOGIN ‚Äî genera JWT + CSRF
app.post('/login', (req, res) => {
  const { username } = req.body;
  const jwtToken = jwt.sign({ username }, process.env.JWT_SECRET, { expiresIn: '1h' });
  const csrfToken = generateCSRFToken();

  // Guardar CSRF token vinculado al usuario (ejemplo simple, en memoria o DB)
  // Aqu√≠, para demo, lo devolvemos directamente
  res.cookie('token', jwtToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'none',
    maxAge: 60 * 60 * 1000,
  });

  // Enviar el CSRF token al frontend
  res.json({ csrfToken });
});

// Ruta protegida
app.post('/update-profile', authMiddleware, (req, res) => {
  const clientCSRF = req.headers['x-csrf-token'];
  if (!clientCSRF) return res.status(403).json({ message: 'Falta CSRF token' });

  // Aqu√≠ podr√≠as validar el token guardado en DB o en sesi√≥n si lo implementas
  // (para este ejemplo asumimos que es v√°lido)
  res.json({ message: `Perfil de ${req.user.username} actualizado correctamente.` });
});

// LOGOUT ‚Äî borra JWT y renueva CSRF vac√≠o
app.post('/logout', (req, res) => {
  res.clearCookie('token', { sameSite: 'none', secure: true });
  const newCSRF = generateCSRFToken(); // token nuevo, sin sesi√≥n activa
  res.json({ csrfToken: newCSRF });
});

app.listen(4000, () => console.log('‚úÖ Backend seguro en http://localhost:4000'));

‚öõÔ∏è FRONTEND (React)
AuthContext.jsx

Guarda el CSRF token y lo actualiza en login/logout autom√°ticamente üëá

import { createContext, useContext, useState } from 'react';

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [csrfToken, setCsrfToken] = useState('');
  const [user, setUser] = useState(null);

  async function login(username) {
    const res = await fetch('https://backend.com/login', {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username }),
    });
    const data = await res.json();
    setCsrfToken(data.csrfToken);
    setUser(username);
  }

  async function logout() {
    const res = await fetch('https://backend.com/logout', {
      method: 'POST',
      credentials: 'include',
    });
    const data = await res.json();
    setUser(null);
    setCsrfToken(data.csrfToken); // ‚ö° Nuevo token (sin sesi√≥n)
  }

  return (
    <AuthContext.Provider value={{ user, csrfToken, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  return useContext(AuthContext);
}

Ejemplo de uso (App.jsx)
import { useAuth } from './AuthContext';

export default function App() {
  const { user, csrfToken, login, logout } = useAuth();

  async function updateProfile() {
    const res = await fetch('https://backend.com/update-profile', {
      method: 'POST',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken,
      },
      body: JSON.stringify({ name: 'Nuevo nombre' }),
    });
    const data = await res.json();
    alert(data.message);
  }

  return (
    <div>
      <h1>Hola {user || 'invitado'}</h1>
      {!user ? (
        <button onClick={() => login('juan')}>Login</button>
      ) : (
        <>
          <button onClick={logout}>Logout</button>
          <button onClick={updateProfile}>Actualizar perfil</button>
        </>
      )}
    </div>
  );
}

üîê Resumen del flujo
Acci√≥n	Backend hace	Frontend hace
Login	Crea JWT + nuevo CSRF token	Guarda token en memoria
Request protegida	Valida JWT y CSRF	Env√≠a header X-CSRF-Token
Logout	Borra cookie JWT + genera CSRF vac√≠o	Limpia usuario y actualiza token



EJEMPLO3
**********************************************
Instalar csurf
npm install csurf

2Ô∏è‚É£ Configurar middleware CSRF en index.js o tu main server
import express from 'express';
import cookieParser from 'cookie-parser';
import csurf from 'csurf';
import usuariosRouter from './routes/usuarios.js';

const app = express();

app.use(express.json());
app.use(cookieParser());

// Configuraci√≥n CSRF
const csrfProtection = csurf({
    cookie: {
        httpOnly: true,
        secure: true,       // si usas HTTPS
        sameSite: 'none',   // porque tu frontend est√° en otro dominio
    }
});

// Endpoint para obtener token CSRF
app.get('/api/v1/erroak/csrf-token', csrfProtection, (req, res) => {
    res.json({ csrfToken: req.csrfToken() });
});

// Aplicar csrfProtection solo a rutas que modifican datos
app.use('/api/v1/erroak', usuariosRouter);

export default app;


Nota: solo protegemos rutas POST, PUT, DELETE que cambian datos; GET no necesita CSRF.

3Ô∏è‚É£ Integrar CSRF en tu router (usuarios.js)

Primero, importa el middleware:

import csurf from 'csurf';
const csrfProtection = csurf({ cookie: true });


Luego aplica csrfProtection a rutas que modifican datos. Ejemplo:

// Crear usuario
router.post('/usuario', registerLimiter, csrfProtection, async(req, res) => {
    const usuario = req.body;
    const resultUsuario = await postUsuario(usuario);
    res.json(resultUsuario);
});

// Actualizar usuario
router.put('/usuario/:id', updateUserLimiter, authenticateToken, csrfProtection, async(req, res) => {
    const id = req.params.id;
    const updatedUser = req.body;
    const result = await putUsuario(id, updatedUser);
    res.json(result);
});

// Logout (limpia cookie CSRF tambi√©n)
router.post('/logout', authenticateToken, csrfProtection, (req, res) => {
    res.clearCookie('token', { httpOnly: true, secure: true, sameSite: 'none' });
    res.clearCookie('_csrf'); // limpiar cookie CSRF
    res.json({ message: 'Sesi√≥n cerrada' });
});


Las rutas GET (/usuarios, /me, /usuario/:id, /getsignupformdata) no requieren CSRF.

4Ô∏è‚É£ En el frontend React

Obtener token CSRF al cargar la app:

async function fetchCsrfToken() {
    const res = await fetch('https://tu-backend.com/api/v1/erroak/csrf-token', {
        credentials: 'include', // env√≠a cookies
    });
    const data = await res.json();
    return data.csrfToken;
}


Enviar el token en headers en cada POST/PUT/DELETE:

const csrfToken = await fetchCsrfToken();

fetch('https://tu-backend.com/api/v1/erroak/usuario', {
    method: 'POST',
    credentials: 'include', // cookies httpOnly
    headers: {
        'Content-Type': 'application/json',
        'csrf-token': csrfToken // CSRF token obligatorio
    },
    body: JSON.stringify(usuario)
});

‚úÖ Beneficios de este setup

Mantienes JWT httpOnly para proteger contra XSS.

A√±ades protecci√≥n CSRF para POST/PUT/DELETE.

No necesitas mover JWT al header Authorization si quieres mantener cookies.

Compatible con frontend en otro dominio (sameSite: 'none', secure: true).

