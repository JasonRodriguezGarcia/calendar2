PARTIENDO DE 14InstalacionServidorTEST1.txt HASTA LA INSTALACION DE DOCKER ENGINE
SEGUIMOS ...

separar frontend y backend en contenedores es lo mÃ¡s limpio, incluso en Windows Server 2022.
Vamos a hacerlo bien y claro, usando Vite + Express, 2 contenedores, y Nginx delante.

Seguimos en Docker modo Windows (contenedores Windows).

ğŸ§± Arquitectura final
Docker
â”œâ”€ frontend  (Nginx + React build)
â”œâ”€ backend   (Node + Express)
â””â”€ (Postgres â†’ Supabase externo)


Flujo:

Usuario â†’ Nginx (frontend)
               â””â”€ /api â†’ Express (backend)

ğŸ“ Estructura del proyecto
project/
â”œâ”€ frontend/
â”‚  â”œâ”€ dist/              â† generado por Vite
â”‚  â”œâ”€ nginx.conf
â”‚  â””â”€ Dockerfile
â”œâ”€ backend/
â”‚  â”œâ”€ server.js
â”‚  â”œâ”€ package.json
â”‚  â””â”€ Dockerfile
â””â”€ docker-compose.yml

1ï¸âƒ£ Backend â€” Express (contenedor Windows)
backend/server.js
const express = require("express");
const app = express();

const PORT = process.env.PORT || 3000;

app.get("/api/health", (req, res) => {
  res.json({ status: "ok" });
});

app.listen(PORT, () => {
  console.log(`Backend running on port ${PORT}`);
});

backend/Dockerfile
FROM mcr.microsoft.com/windows/servercore:ltsc2022

# Node.js
RUN powershell -Command `
  Invoke-WebRequest https://nodejs.org/dist/v18.20.4/node-v18.20.4-x64.msi -OutFile node.msi ; `
  Start-Process msiexec.exe -ArgumentList '/i node.msi /quiet' -Wait ; `
  Remove-Item node.msi

WORKDIR C:/app

COPY package.json .
RUN npm install --production

COPY . .

EXPOSE 3000
CMD ["node", "server.js"]

2ï¸âƒ£ Frontend â€” React + Vite (Nginx)
Build de Vite (antes de Docker)
cd frontend
npm install
npm run build


Esto genera frontend/dist.

frontend/nginx.conf
events {}

http {
  server {
    listen 80;

    root C:/nginx/html;
    index index.html;

    location / {
      try_files $uri /index.html;
    }

    location /api/ {
      proxy_pass http://backend:3000;
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
    }
  }
}

frontend/Dockerfile
FROM mcr.microsoft.com/windows/servercore:ltsc2022

# Descargar Nginx
RUN powershell -Command `
  Invoke-WebRequest https://nginx.org/download/nginx-1.24.0.zip -OutFile nginx.zip ; `
  Expand-Archive nginx.zip C:/ ; `
  Rename-Item C:/nginx-1.24.0 C:/nginx ; `
  Remove-Item nginx.zip

COPY nginx.conf C:/nginx/conf/nginx.conf
COPY dist C:/nginx/html

EXPOSE 80
CMD ["C:/nginx/nginx.exe", "-g", "daemon off;"]

3ï¸âƒ£ Docker Compose (la pieza clave)
docker-compose.yml
version: "3.9"

services:
  backend:
    build: ./backend
    container_name: backend
    environment:
      - NODE_ENV=production
      - PORT=3000
      - DATABASE_URL=postgresql://USER:PASSWORD@HOST:5432/DB
    restart: always

  frontend:
    build: ./frontend
    container_name: frontend
    ports:
      - "80:80"
    depends_on:
      - backend
    restart: always

ğŸš€ Levantar todo

Desde la raÃ­z del proyecto:
    docker compose up -d --build

Pruebas:
    Web: http://IP_DEL_SERVIDOR
    API: http://IP_DEL_SERVIDOR/api/health

ğŸŸ¢ Ventajas de esta separaciÃ³n

âœ”ï¸ Frontend y backend independientes
âœ”ï¸ Escalable (maÃ±ana replicas backend)
âœ”ï¸ React servido por Nginx (mÃ¡s rÃ¡pido)
âœ”ï¸ Arquitectura estÃ¡ndar de producciÃ³n
âœ”ï¸ Supabase externo = menos carga

âš ï¸ Nota honesta
Esto funciona bien en Windows, pero:
    imÃ¡genes grandes
    builds lentos

Si algÃºn dÃ­a pasas a WSL2 / Linux, este mismo diseÃ±o te sirve sin cambios (solo Dockerfiles mÃ¡s simples).
Si quieres, el siguiente paso puede ser:
    HTTPS
    variables .env
    optimizar imÃ¡genes
    o versiÃ³n Linux equivalente para el futuro

**********************
**********************
**********************
**********************
ğŸ§  QuÃ© hace docker compose up
Cuando ejecutas:
    docker compose up -d --build
Docker Compose hace esto, en orden:

1ï¸âƒ£ Lee docker-compose.yml
Ve algo como:
services:
  frontend:
    build: ./frontend
  backend:
    build: ./backend
ğŸ‘‰ Eso le dice:
â€œPara cada servicio, construye una imagen desde esta carpetaâ€.

2ï¸âƒ£ Busca un Dockerfile
En cada carpeta (./frontend, ./backend):
Busca un archivo llamado Dockerfile
Si existe â†’ lo ejecuta lÃ­nea por lÃ­nea
Ejemplo:

FROM ...
RUN ...
COPY ...
CMD ...
ğŸ‘‰ Esto crea una imagen (no el contenedor todavÃ­a).

3ï¸âƒ£ Crea las imÃ¡genes
    Imagen project_frontend
    Imagen project_backend
(El nombre depende del proyecto).
Las imÃ¡genes quedan guardadas localmente.

4ï¸âƒ£ Crea los contenedores
Con esas imÃ¡genes:
    Crea un contenedor para frontend
    Crea un contenedor para backend

Aplica:
    variables de entorno
    puertos
    red interna
    dependencias (depends_on)

5ï¸âƒ£ Ejecuta el CMD / ENTRYPOINT
En cada contenedor:
    Arranca lo que diga el CMD

Ejemplo:
    CMD ["node", "server.js"]
    o
    CMD ["nginx.exe", "-g", "daemon off;"]
ğŸ‘‰ Ese proceso es el proceso principal del contenedor.

ğŸ” QuÃ© pasa si vuelves a ejecutar
docker compose up -d
âŒ No vuelve a ejecutar el Dockerfile
âœ”ï¸ Usa las imÃ¡genes ya creadas

Si haces:
docker compose up -d --build
âœ”ï¸ Vuelve a ejecutar el Dockerfile
âœ”ï¸ Reconstruye imÃ¡genes
ğŸ§© Detalle importante

Si cambias cÃ³digo:
    Backend â†’ necesitas --build
    Frontend â†’ primero npm run build, luego --build

Docker no recompila React solo.

ğŸŸ¢ Resumen en una frase
ğŸ‘‰ SÃ­:
docker compose crea los contenedores,
    y si hay un Dockerfile, lo ejecuta para construir la imagen antes de arrancarlos.

Lo tienes perfectamente claro ğŸ‘Œ
Si quieres, el siguiente nivel es:
    ver imÃ¡genes vs contenedores
    entender redes internas (backend:3000)
    o optimizar rebuilds
