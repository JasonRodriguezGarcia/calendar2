npm create vite@latest frontend

cd frontend    
npm install    
npm run dev

npm i react-big-calendar

npm i date-fns

********

    git add .
    git commit -m "first commit"
    git remote add origin https://github.com/JasonRodriguezGarcia/calendar2.git
    git branch -M main
    git push -u origin main

***************

npm install @mui/material @emotion/react @emotion/styled @mui/icons-material
npm install @mui/x-date-pickers @date-io/date-fns

***************
npm install react-router-dom

***************

abrir el contenedor de docker de nuestro compose.yml (que ya estÃ¡ configurado con postgres-db y pg_admin)
    docker compose up -d

Ya tenemos funcionando en segundo plano la bbdd postgresql y pg_admin para su administraciÃ³n
Para abrir la administracion de la bbdd con pg_admin, abrir en navegador
    http://localhost:5050/

postgresql
en navegador ponemos localhost:5050 y entramos en la interfaz de postgresql del fichero docker_composer
OJO AL ENTRAR SELECCIONAR EN ESPAÃ‘OL EN LA OPCION DE ABAJO
entrar con
    jasonrodriguezempleo@gmail.com
    postgres  (contraseÃ±a del fichero docker_composer)

dentro
    boton derecho en servers (a la izq)
    register - servidor
    en pestaÃ±a general
    nombre postgres
    conexion
    nombre postgres
    usuario: postgres
    contraseÃ±a : postgresj
    boton SALVAR

a la izq
    servers
        postgres
            Bases de datos
            Boton derecho en Bases de datos - crear - base de datos
            nombre: demo
            salvar
a la izq
dentro de SERVERS aparecerÃ¡ un icono de POSTGRES y lo abrimos 
bases de datos boton DERECHO - CREAR - BASE DE DATOS
Base de datos pondremos: demo
boton SALVAR


***************
fichero de mern_4 0leemeDia26Junio.txt con informaciÃ³n de nginx

directorio de mern_4 my-express-app con indicaciones para montar contenedor con express
***************
***************

Para que al dar F5 estando en cualquier ruta como pueda ser https://calendar2-6wyj.onrender.com/holidays el navegador
no nos devuelva NOT FOUND

En Render tenemos que configurar en frontend el apartado Redirect/Rewrite con los siguiente parÃ¡metros
    - Usando Vite
        Source:	/*
        Destination: /index.html
        Action:	Rewrite

Diferencia entre Redirect y Rewrite
ğŸ” 1. Redirect (RedirecciÃ³n)

Cambia la URL del navegador.
Le dice al navegador: "Ve a otra direcciÃ³n"
El navegador recarga la pÃ¡gina con la nueva URL.
Ejemplo:

Si alguien entra a tusitio.com/login
Lo rediriges a tusitio.com/iniciar-sesion
ğŸ‘‰ La URL cambia visiblemente
ğŸ‘‰ Ãštil para redirecciones permanentes, migraciÃ³n de rutas, etc.

ğŸ“ 2. Rewrite (Reescritura)
NO cambia la URL del navegador.
El servidor responde con otro archivo internamente, pero la URL se mantiene.

Ejemplo tÃ­pico en SPAs (React, Vite, Vue):
Usuario entra a tusitio.com/dashboard
Render no encuentra un archivo /dashboard

Pero con la regla:
/* â†’ /index.html (Rewrite)
Render devuelve index.html, y React Router se encarga de mostrar la vista correcta.
ğŸ‘‰ Reglas de Rewrite son esenciales para Single Page Applications.
Las Redirect and Rewrite Rules (Reglas de redirecciÃ³n y reescritura) son configuraciones que te permiten controlar 
cÃ³mo un servidor maneja las URLs que le llegan.
Render (y otros servicios como Netlify o Vercel) las usan para saber quÃ© hacer con cada ruta que visita el usuario.
Como Vite/React Router manejan las rutas del lado del cliente, el servidor debe siempre devolver index.html para 
cualquier ruta que NO sea un archivo real.

Por eso configuras:
Source	Destination	Action
/*	/index.html	Rewrite
âœ”ï¸ Â¿Para quÃ© sirve esto en la prÃ¡ctica?

Para que al recargar una pÃ¡gina como /profile, no salga un 404.
Para que las rutas del frontend funcionen correctamente.
Para servir tu SPA desde un solo archivo inicial.



***************
EJEMPLOS  PARA USAR ENVIO DE CORREO ELECTRONICO DESDE BACKEND GRATIS
1- SENDGRID (OJO TIENE CADUCIDAD A DÃA 26/11/2025)
EN BACKEND
    npm install @sendgrid/mail
DARSE ALTA EN SENDGRID (es twilio product)
Una vez logeado
CREAR API KEY en 
    SETTINGS - API KEY
Luego aÃ±adimos la direcciÃ³n de correo origen del email
    SETTINGS
        sender autentication
        AparecerÃ¡ una nueva pantalla en la que uno de los botones pondrÃ¡
            VERIFY A SINGLE sender
            Lo que nos permitirÃ¡ meter una direcciÃ³n de mail que usaremos como origen del email
            Que luego tendremos que verificar, lo cual haremos al crearla, ya recibiremos un email que tengremos que contestar
        TambiÃ©n tendremos que hacer un domain autentication para que el receptor de los correos no reciba un aviso de 
        correo no verificado
            DOMAIN AUTHENTICACION
            Verifica el dominio en SendGrid
            Para que los correos no aparezcan como "NO VERIFICADO", debes verificar que el dominio erroak.sartu.org estÃ© autenticado en tu cuenta de SendGrid.
            Pasos:
            Entra en https://app.sendgrid.com/settings/sender_auth
            En la secciÃ³n "Domain Authentication", haz clic en "Get Started".
            Selecciona tu proveedor de DNS (por ejemplo, Cloudflare, GoDaddy, etc.).
            Ingresa el dominio: erroak.sartu.org.
            SendGrid te darÃ¡ varios registros DNS (como CNAME) que debes aÃ±adir en el panel DNS de tu dominio.
            Una vez aÃ±adidos, vuelve a SendGrid y haz clic en "Verify".
            âœ… Importante: Este paso puede tardar un poco en propagarse (hasta 24h), pero normalmente es rÃ¡pido.

            Otros pasos: (Parece lo mismo)
Si ya hiciste el Single Sender Verification y aÃºn ves â€œNO VERIFICADOâ€, esto es lo que estÃ¡ pasando:
Por quÃ© sigue apareciendo â€œNO VERIFICADOâ€
Single Sender vs Dominio autenticado
La verificaciÃ³n de remitente Ãºnico solo confirma que SendGrid puede enviar correos desde esa direcciÃ³n especÃ­fica, pero no 
cambia cÃ³mo los clientes de correo validan el dominio.
Gmail, Outlook y Apple Mail verifican el dominio, no solo la direcciÃ³n de correo.
Como el dominio no estÃ¡ autenticado con DKIM/SPF, los correos aparecen â€œvia SendGridâ€ o â€œNO VERIFICADOâ€.
Cliente de correo estricto
Algunos clientes, como Gmail, muestran â€œNO VERIFICADOâ€ incluso si el remitente estÃ¡ verificado en SendGrid, mientras no haya registros DKIM y SPF correctos.
CÃ³mo eliminar el â€œNO VERIFICADOâ€
A) Para que desaparezca por completo, necesitas autenticar tu dominio (no solo un remitente Ãºnico):
Ve a Settings â†’ Sender Authentication â†’ Authenticate Your Domain en SendGrid.
Introduce tu dominio propio (ej. midominio.com) y tu proveedor de DNS.
AÃ±ade los registros CNAME que SendGrid te da a tu DNS.
Espera la propagaciÃ³n DNS (puede tardar minutos u horas).
EnvÃ­a un correo desde cualquier direcciÃ³n de tu dominio autenticado, y Gmail/Outlook ya mostrarÃ¡n tu dominio como verificado.


B) Otra forma es poner:
    abrir https://dnschecker.org/ns-lookup.php
    en Enter Domain to Check NS Records: poner sartu.org y ENTER
    mÃ¡s abajo aparecen resultados en Results for: SARTU.org
        Type    Domain Name     TTL     Address 
        NS      sartu.org       21600   ns4.cdmondns-01.org. ( 52.58.66.183  Check IP Blacklist )
                                        Owner: A100 ROW GmbH Germany  WHOIS  AS16509

        Type    Domain Name     TTL     Address 
        NS      sartu.org       21600   ns5.cdmondns-01.com. ( 52.59.146.62  Check IP Blacklist )
                                        Owner: A100 ROW GmbH Germany  WHOIS  AS16509
        Type    Domain Name     TTL     Address 
        NS      sartu.org       21600   ns1.cdmon.net. ( 35.189.106.232  Check IP Blacklist )
                                        Owner: Google LLC United Kingdom of Great Britain and Northern Ireland  WHOIS  AS396982
        Type    Domain Name     TTL     Address 
        NS      sartu.org       21600   ns2.cdmon.net. ( 35.195.57.29  Check IP Blacklist )
                                        Owner: Google LLC Belgium  WHOIS  AS396982
        Type    Domain Name     TTL     Address 
        NS      sartu.org       21600   ns3.cdmon.net. ( 35.157.47.125  Check IP Blacklist )
                                        Owner: A100 ROW GmbH Germany  WHOIS  AS16509
    Lo cual indica que Tu dominio sartu.org usa los nameservers de CDmon.
    El dominio sartu.org tiene los DNS gestionados en CDmon.

    Esto quiere decir:

    â¡ï¸ Todo lo relacionado con SPF, DKIM, CNAME, MXâ€¦ debes configurarlo en el panel de CDmon.
    â¡ï¸ SendGrid SOLO funcionarÃ¡ si aÃ±ades los registros en CDmon â†’ Zona DNS.

    Â¿QuÃ© debes hacer ahora?
        1ï¸âƒ£ Entra en CDmon
            Panel:
            ğŸ‘‰ https://cdmon.com/es (aparece un nÃºmero telefÃ³nico en la web)

            Accede con la cuenta que administra el dominio sartu.org.
        2ï¸âƒ£ Busca la secciÃ³n:
                â€œDNSâ€
                â€œEditor DNSâ€
                â€œGestiÃ³n de zona DNSâ€
                â€œRegistros DNSâ€
                En CDmon normalmente se llama:
                â€œAdministrador de DNSâ€ â†’ â€œZona DNSâ€
            Ã³ algo asÃ­ como:
                Dominios â†’ Mis Dominios
                Seleccionas sartu.org
                Entras a DNS & Dominios
                Luego a Administrador de DNS o GestiÃ³n de zona DNS
                Busca algo como:
                    âœ” â€œÃrea DNSâ€
                    âœ” â€œRegistros DNSâ€
                    âœ” â€œZona DNSâ€
                AhÃ­ es donde podrÃ¡s aÃ±adir LOS RESULTADOS CNAME DE ABAJO EN ESTE FORMATO

        3ï¸âƒ£ AÃ±ade los CNAME que SendGrid te darÃ¡
            DespuÃ©s de poner en SendGrid:
                DNS Host: Other
                Which DNS Host: CDmon
                Branding links: YES
                Domain: erroak.sartu.org
            CNAME RESULTADOS
                Type	Host                        Value
                CNAME	url9354.erroak.sartu.org	sendgrid.net	

                Type	Host                        Value
                CNAME	56270334.erroak.sartu.org	sendgrid.net	

                Type	Host                        Value
                CNAME	em1037.erroak.sartu.org	    u56270334.wl085.sendgrid.net	

                Type	Host                            Value
                CNAME	s1._domainkey.erroak.sartu.org	s1.domainkey.u56270334.wl085.sendgrid.net	

                Type	Host                            Value
                CNAME	s2._domainkey.erroak.sartu.org	s2.domainkey.u56270334.wl085.sendgrid.net	

                Type	Host                        Value
                TXT	    _dmarc.erroak.sartu.org	    v=DMARC1; p=none;	

                En CDmon:
                ğŸ‘‰ En "Nombre / Host / Alias"
                Debes poner solo lo que va antes del dominio:
                Datos a introducir Y ASÃ CON TODOS:
                Lista exacta de registros para CDmon
                    AquÃ­ tienes todo exactamente como debe quedar:
                    ğŸ”µ CNAME 1 â€” Link branding
                        Host	url9354
                        Tipo	        CNAME
                        Destino	        sendgrid.net
                    ğŸ”µ CNAME 2 â€” Link branding secundario
                    Host:               56270334
                    Tipo:               CNAME
                    Destino (Value):    sendgrid.net

                    ğŸ”µ CNAME 3 â€” Domain authentication (SendGrid root)
                    Host:               em1037
                    Tipo:               CNAME
                    Destino (Value):    u56270334.wl085.sendgrid.net

                    ğŸ”µ CNAME 4 â€” DKIM 1
                    Host:               s1._domainkey
                    Tipo:               CNAME
                    Destino (Value):    s1.domainkey.u56270334.wl085.sendgrid.net

                    ğŸ”µ CNAME 5 â€” DKIM 2
                    Host:               s2._domainkey
                    Tipo:               CNAME
                    Destino (Value):    s2.domainkey.u56270334.wl085.sendgrid.net

                    ğŸ”µ TXT â€” DMARC
                    Host:               _dmarc
                    Tipo:               TXT
                    Valor:              v=DMARC1; p=none;
                                        (Es opcional, pero SendGrid lo recomienda. Puedes cambiar luego p=none por 
                                        quarantine o reject si quieres endurecer seguridad.)
***
EJEMPLO
            SendGrid te darÃ¡ algo asÃ­ (ejemplo):
                Tipo	Host	        Valor
                CNAME	em1234	        u123456.wl.sendgrid.net
                CNAME	s1._domainkey	s1.domainkey.u123456.wl.sendgrid.net
                CNAME	s2._domainkey	s2.domainkey.u123456.wl.sendgrid.net
            ğŸ“Œ Los valores exactos los da SendGrid en tu cuenta. NO uses estos.

            âš ï¸ Muy importante al aÃ±adirlos en CDmon
            En CDmon:
            ğŸ‘‰ En "Nombre / Host / Alias"
            Debes poner solo lo que va antes del dominio:
            Ejemplo real de cÃ³mo se introduce:
                Campo           Lo que pones
                Nombre / Host	em1234
                Tipo	        CNAME
                Destino	        u123456.wl.sendgrid.net
***

        4ï¸âƒ£ Validar en SendGrid
            DespuÃ©s de guardar los registros en CDmon:
            Espera entre 5 y 20 minutos
            Vuelve a SendGrid â†’ Authenticate Domain â†’ "Verify"
            Si todo estÃ¡ correcto:
                âœ” Authenticated
                âœ” Los emails dejan de mostrar â€œNO VERIFICADOâ€
                âœ” SPF + DKIM funcionando
                âœ” Mejor entrega en destinatarios
        Resultado esperado
        Cuando todo estÃ© bien verÃ¡s:
        DKIM â†’ VALID âœ”
        SPF â†’ VALID âœ” (SendGrid aÃ±ade su SPF automÃ¡ticamente)
        Domain Authentication â†’ VALID âœ”
        Link Branding â†’ VALID âœ”
        Y tus correos dejarÃ¡n de aparecer como NO VERIFICADO.

ğŸ’¡ Resumen:
    Single Sender Verification = envÃ­os permitidos desde esa direcciÃ³n, Ãºtil para pruebas.
    Domain Authentication = hace que tu dominio se vea verificado en todos los clientes de correo.
    Solo con domain authentication desaparece â€œNO VERIFICADOâ€ de Gmail, Outlook, etc.




*********************
PENDING MIRAR !!! 
En express
    npm install express-validator (para velidaciÃ³n de rutas)

express-validator es un paquete para Node.js que proporciona middlewares para validar y sanear datos de entrada en aplicaciones Express.js, permitiendo verificar que la informaciÃ³n recibida en las peticiones (como el cuerpo, parÃ¡metros o query strings) cumple ciertos criterios y transformarla para mejorar la seguridad. Se integra con la biblioteca validator.js y usa una "cadena" de validaciones para definir reglas para cada campo de datos. 
Â¿CÃ³mo funciona?
1. ValidaciÃ³n: express-validator permite definir reglas para cada campo que se espera en una peticiÃ³n. Por ejemplo, puedes especificar que un campo de email debe tener un formato de correo electrÃ³nico vÃ¡lido, o que un campo de contraseÃ±a debe tener una longitud mÃ­nima. 
2. Saneamiento: TambiÃ©n incluye funciones para "sanear" los datos, lo cual ayuda a prevenir ataques de seguridad. Esto puede incluir la limpieza de espacios en blanco o la conversiÃ³n de tipos de datos. 
3. Middleware: Se integra como middleware en Express.js, lo que significa que se ejecuta antes de que la lÃ³gica principal de tu ruta o controlador sea llamada. 
4. Resultados de la validaciÃ³n: Si las validaciones fallan, express-validator devuelve un objeto con los errores, permitiendo enviarlos de vuelta al cliente o manejar la respuesta adecuadamente. 
Usos comunes
ValidaciÃ³n de formularios: Asegurar que los datos ingresados en formularios web son correctos antes de procesarlos en el backend. 
APIs: Verificar que los datos enviados a tu API cumplen los requisitos definidos, como la estructura de un JSON. 
Seguridad: Prevenir vulnerabilidades como la inyecciÃ³n de cÃ³digo al sanear los datos de entrada. 
Ejemplo rÃ¡pido
JavaScript

const express = require('express');
const { body, validationResult } = require('express-validator'); // Importa body y validationResult

const app = express();

app.post('/registro', [
  // Reglas de validaciÃ³n para los campos email y contraseÃ±a
  body('email').isEmail().withMessage('Por favor, introduce un email vÃ¡lido'),
  body('password').isLength({ min: 5 }).withMessage('La contraseÃ±a debe tener al menos 5 caracteres'),
], (req, res) => {
  const errors = validationResult(req); // Captura los errores de validaciÃ³n

  if (!errors.isEmpty()) {
    // Si hay errores, los devuelve al cliente
    return res.status(400).json({ errors: errors.array() });
  }

  // Si todo estÃ¡ bien, procede con la lÃ³gica del registro
  // ...
});

app.listen(3000, () => console.log('Servidor en el puerto 3000'));
En este ejemplo, se usa body() para validar campos en el cuerpo de la peticiÃ³n, se comprueba que el email sea vÃ¡lido y la password tenga al menos 5 caracteres. Si no, se devuelven los errores. 
*********************
OTRO PARA ENVIO DE CORREO ELECTRONICO DESDE BACKEND
2- MAILGUN (MAXIMO 100 CORREOS AL DÃA, SIN PERIODO DE PRUEBA A DIA 26/11/2025)

Crear cuenta gratuita en Mailgun
Entra en mailgun.com

RegÃ­strate (elige el plan gratuito â†’ incluye envÃ­os de prueba).

Verifica tu email.
Te pedirÃ¡ crear un dominio de envÃ­o:
Puedes usar un dominio propio (â€œmg.tudominio.comâ€)
O usar un dominio sandbox gratuito que Mailgun te proporciona.
ğŸ‘‰ Para pruebas con backend NO necesitas verificar un dominio, puedes usar el sandbox domain.
âœ… 2. Obtener las credenciales necesarias
En tu dashboard de Mailgun:
    Ve a Sending â†’ Domains â†’ tu dominio (o sandbox).
        Add sending key
Copia:
    API Key (Private API Key)
Domain name (ej: sandbox12345.mailgun.org)

InstalaciÃ³n en Express
    npm install mailgun-js

Crea tu archivo de variables de entorno:
.env
    MAILGUN_API_KEY=tu_api_key
    MAILGUN_DOMAIN=tu_dominio

index.js
import express from 'express';
import Mailgun from 'mailgun-js';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
app.use(express.json());

// ConfiguraciÃ³n Mailgun
const mg = Mailgun({
  apiKey: process.env.MAILGUN_API_KEY,
  domain: process.env.MAILGUN_DOMAIN
});

app.post('/send-email', async (req, res) => {
  const { to, subject, text, html } = req.body;

  const data = {
    from: "Mi App <no-reply@tu-dominio.com>",
    to,
    subject,
    text,
    html
  };

  try {
    const result = await mg.messages().send(data);
    console.log("Email enviado:", result);
    res.json({ success: true, result });
  } catch (error) {
    console.error("Error al enviar:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

app.listen(3000, () => {
  console.log("Servidor corriendo en http://localhost:3000");
});
âœ… 5. Probar el envÃ­o de emails
Puedes usar Postman, Insomnia o curl.

Ejemplo:

POST â†’ http://localhost:3000/send-email
Body â†’ JSON:

json
Copiar cÃ³digo
{
  "to": "tu-email@ejemplo.com",
  "subject": "Prueba de Mailgun",
  "text": "Hola! Este es un correo de prueba.",
  "html": "<h1>Hola!</h1><p>Este es un correo HTML.</p>"
}
ğŸ§ª 6. Â¡OJO! Email de pruebas (sandbox)
Si usas un dominio sandbox, Mailgun solo permite enviar correos a direcciones verificadas.

Para verificar una direcciÃ³n:

En Mailgun â†’ Sending â†’ Domains â†’ tu sandbox.

En "Authorized Recipients", aÃ±ade tu correo.

Luego podrÃ¡s aceptar el correo de confirmaciÃ³n y comenzar a recibir emails.

â­ BONUS: cÃ³mo enviar un email simple desde una funciÃ³n backend
js
Copiar cÃ³digo
export async function sendWelcomeEmail(email, name) {
  const data = {
    from: "Mi App <no-reply@tu-dominio.com>",
    to: email,
    subject: "Bienvenido a nuestra app",
    html: `<h2>Hola ${name}!</h2><p>Gracias por registrarte.</p>`
  };

  return await mg.messages().send(data);
}
ğŸ‰ Ya puedes reemplazar SendGrid por Mailgun
Si quieres, te puedo preparar:

âœ… Un middleware reusable de envÃ­o
âœ… Una versiÃ³n con Nodemailer + SMTP gratuito
âœ… Una versiÃ³n para usar con Brevo (Sendinblue)
âœ… Plantillas de emails listas para producciÃ³n

Â¿Quieres alguna de estas opciones?


